<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from target/generated-site/xdoc/report-aggregate-mojo.xml at 2022-12-08

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>Revapi Maven Plugin &#x2013; revapi:report-aggregate</title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="./" id="bannerLeft">Maven Plugin
</a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2022-12-08</span>
          &#xA0;| <span id="projectVersion">Version: 0.15.0</span>
      </div>
      <div class="xright">      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">

  
    <section>
<h2><a name="revapi:report-aggregate"></a>revapi:report-aggregate</h2>
      
<p><b>Note</b>:This goal should be used as a Maven report.</p>
      
<p><b>Full name</b>:</p>
      
<p>org.revapi:revapi-maven-plugin:0.15.0:report-aggregate</p>
      
<p><b>Description</b>:</p>
      
<div>Uses the configuration supplied at the top level aggregator project
to run analysis on all sub-projects. 

<p>The artifacts to compare are taken from the configurations of
the child projects while the configuration of Revapi and the
extensions to use are taken from the aggregator project. The
analyses are run in succession using a single instance of Revapi.
Therefore you need to configure your custom Revapi reporter(s) to
somehow not overwrite their reports, but append to it. The default
site page generator can do this and the
<code>revapi-reporter-text</code> reporter has an
<code>append</code> boolean parameter for this. If you're using
some other reporter, consult its documentation on how to append to
a report instead of overwriting it.</p></div>
      
<p><b>Attributes</b>:</p>
      
<ul>
        
<li>Requires a Maven project to be executed.</li>
        
<li>Executes as an aggregator plugin.</li>
        
<li>Since version: <code>0.5.0</code>.</li>
        
<li>Binds by default to the <a class="externalLink" href="http://maven.apache.org/ref/current/maven-core/lifecycles.html">lifecycle phase</a>: <code>site</code>.</li>
        
<li>Invokes the execution of the <a class="externalLink" href="http://maven.apache.org/ref/current/maven-core/lifecycles.html">lifecycle phase</a> <code>package</code> prior to executing itself.</li>
      </ul>
      <section>
<h3><a name="Optional_Parameters"></a>Optional Parameters</h3>
        
<table class="bodyTable" border="0">
          
<tr class="a">
            
<th>Name</th>
            
<th>Type</th>
            
<th>Since</th>
            
<th>Description</th>
          </tr>
          
<tr class="b">
            
<td><code><a href="#alwaysCheckForReleaseVersion">&lt;alwaysCheckForReleaseVersion&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>If true (the default) revapi will always download the information
about the latest version from the remote repositories (instead of
using locally cached info). This will respect the offline settings.<br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.alwaysCheckForReleaseVersion</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#analysisConfiguration">&lt;analysisConfiguration&gt;</a></code></td>
            
<td><code>PlexusConfiguration</code></td>
            
<td><code>0.5.0</code></td>
            
<td>The JSON or XML configuration of various analysis options. The
available options depend on what analyzers are present on the
plugin classpath through the <code>&lt;dependencies&gt;</code>.
Consult <a href="examples/configuration.html">configuration
documentation</a> for more details. 

<p>These settings take precedence over the configuration loaded
from <code>analysisConfigurationFiles</code>.</p><br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#analysisConfigurationFiles">&lt;analysisConfigurationFiles&gt;</a></code></td>
            
<td><code>Object[]</code></td>
            
<td><code>0.5.0</code></td>
            
<td>The list of files containing the configuration of various analysis
options. The available options depend on what analyzers are present
on the plugins classpath through the
<code>&lt;dependencies&gt;</code>. 

<p>The <code>analysisConfiguration</code> can override the settings
present in the files.</p>

<p>The list is either a list of strings or has the following
form:</p>

<div>
<pre>
<code>
  &lt;analysisConfigurationFiles&gt;
       &lt;configurationFile&gt;
           &lt;path&gt;path/to/the/file/relative/to/project/base/dir&lt;/path&gt;
           &lt;resource&gt;path/to/the/file/in/one/of/the/dependencies&lt;/resource&gt;
           &lt;roots&gt;
               &lt;root&gt;configuration/root1&lt;/root&gt;
               &lt;root&gt;configuration/root2&lt;/root&gt;
               ...
           &lt;/roots&gt;
       &lt;/configurationFile&gt;
       ...
   &lt;/analysisConfigurationFiles&gt;
</code>
</pre></div>

where 

<ul>

<li><code>path</code> is the path on the filesystem,</li>

<li><code>resource</code> is the path to the resource file in one
of the artifacts the plugin depends on</li>

<li><code>roots</code> is optional and specifies the subtrees of
the JSON/XML config that should be used for configuration. If not
specified, the whole file is taken into account.</li>
</ul>
Either <code>path</code> or <code>resource</code> has to be
specified but not both. The <code>configuration/root1</code> and
<code>configuration/root2</code> are paths to the roots of the
configuration inside that JSON/XML config file. This might be used
in cases where multiple configurations are stored within a single
file and you want to use a particular one. 

<p>An example of this might be a config file which contains API
changes to be ignored in all past versions of a library. The
classes to be ignored are specified in a configuration that is
specific for each version:</p>

<div>
<pre>
<code>
   {
        &quot;0.1.0&quot; : [
            {
                &quot;extension&quot;: &quot;revapi.ignore&quot;,
                &quot;configuration&quot;: [
                    {
                        &quot;code&quot; : &quot;java.method.addedToInterface&quot;,
                        &quot;new&quot; : &quot;method void com.example.MyInterface::newMethod()&quot;,
                        &quot;justification&quot; : &quot;This interface is not supposed to be implemented by clients.&quot;
                    },
                    ...
                ]
            }
        ],
        &quot;0.2.0&quot; : [
            ...
        ]
    }
</code>
</pre></div><br /><b>User property is</b>: <code>revapi.analysisConfigurationFiles</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#checkDependencies">&lt;checkDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>Whether to include the dependencies in the API checks. This is the
default thing to do because your API might be exposing classes from
the dependencies and thus classes from your dependencies could
become part of your API. 

<p>However, setting this to false might be useful in situations
where you have checked your dependencies in another module and
don't want do that again. In that case, you might want to configure
Revapi to ignore missing classes because it might find the classes
from your dependencies as used in your API and would complain that
it could not find it. See <a class="externalLink" href="http://revapi.org/modules/revapi-java/extensions/java.html">the
docs</a>.</p><br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.checkDependencies</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#disallowedExtensions">&lt;disallowedExtensions&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.5.0</code></td>
            
<td>A comma-separated list of extensions (fully-qualified class names
thereof) that are not taken into account during API analysis. By
default, all extensions that are found on the classpath are used. 

<p>You can modify this set if you use another extensions that
change the found differences in a way that the determined new
version would not correspond to what it should be.</p><br /><b>User property is</b>: <code>revapi.disallowedExtensions</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#expandProperties">&lt;expandProperties&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.11.6</code></td>
            
<td>If set to true, the Maven properties will be expanded in the
configuration before it is supplied to Revapi. I.e. any
<code>${var</code>} appearing in the configuration <b>values</b>
will be replaced with the value of the <code>var</code> property as
known to Maven. If the property is not defined, the expansion
doesn't take place.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.expandProperties</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#failOnMissingConfigurationFiles">&lt;failOnMissingConfigurationFiles&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>Set to false if you want to tolerate files referenced in the
<code>analysisConfigurationFiles</code> missing on the filesystem
and therefore not contributing to the analysis configuration. 

<p>The default is <code>true</code>, which means that a missing
analysis configuration file will fail the build.</p><br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.failOnMissingConfigurationFiles</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#failOnUnresolvedArtifacts">&lt;failOnUnresolvedArtifacts&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>If true, the build will fail if one of the old or new artifacts
fails to be resolved. Defaults to false.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.failOnUnresolvedArtifacts</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#failOnUnresolvedDependencies">&lt;failOnUnresolvedDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>If true, the build will fail if some of the dependencies of the old
or new artifacts fail to be resolved. Defaults to false.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.failOnUnresolvedDependencies</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#generateSiteReport">&lt;generateSiteReport&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>Set this to false if you want to use the goal to generate other
kind of output than the default report for the Maven-generated
site. You can generate such output by using different reporting
extensions (like revapi-reporter-text).<br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.generateSiteReport</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#newArtifacts">&lt;newArtifacts&gt;</a></code></td>
            
<td><code>String[]</code></td>
            
<td><code>0.5.0</code></td>
            
<td>The coordinates of the new artifacts. These are the full GAVs of
the artifacts, which means that you can compare different artifacts
than the one being built. If you merely want to specify the
artifact being built, use <code>newVersion</code> property instead.<br /><b>User property is</b>: <code>revapi.newArtifacts</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#newPromotedDependencies">&lt;newPromotedDependencies&gt;</a></code></td>
            
<td><code>PromotedDependency[]</code></td>
            
<td><code>0.13.6</code></td>
            
<td>A list of dependencies of the new artifact(s) that should be
considered part of the new API.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#newVersion">&lt;newVersion&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.5.0</code></td>
            
<td>The new version of the artifact. Defaults to &quot;${project.version}&quot;.<br /><b>Default value is</b>: <code>${project.version}</code>.<br /><b>User property is</b>: <code>revapi.newVersion</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#oldArtifacts">&lt;oldArtifacts&gt;</a></code></td>
            
<td><code>String[]</code></td>
            
<td><code>0.5.0</code></td>
            
<td>The coordinates of the old artifacts. Defaults to single artifact
with the latest released version of the current project. 

<p>If the this property is null, the <code>oldVersion</code>
property is checked for a value of the old version of the artifact
being built.</p><br /><b>User property is</b>: <code>revapi.oldArtifacts</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#oldPromotedDependencies">&lt;oldPromotedDependencies&gt;</a></code></td>
            
<td><code>PromotedDependency[]</code></td>
            
<td><code>0.13.6</code></td>
            
<td>A list of dependencies of the old artifact(s) that should be
considered part of the old API.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#oldVersion">&lt;oldVersion&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.5.0</code></td>
            
<td>If you don't want to compare a different artifact than the one
being built, specifying the just the old version is simpler way of
specifying the old artifact. 

<p>The default value is &quot;RELEASE&quot; meaning that the old version is
the last released version of the artifact being built.</p><br /><b>Default value is</b>: <code>RELEASE</code>.<br /><b>User property is</b>: <code>revapi.oldVersion</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#pipelineConfiguration">&lt;pipelineConfiguration&gt;</a></code></td>
            
<td><code>PlexusConfiguration</code></td>
            
<td><code>0.11.0</code></td>
            
<td>The JSON or XML configuration of the extensions pipeline. This
enables the users easily specify which extensions should be
included/excluded in the Revapi analysis pipeline and also to
define transformation blocks - a way of grouping transforms
together to enable more fine grained control over how differences
are transformed.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#promotedDependencies">&lt;promotedDependencies&gt;</a></code></td>
            
<td><code>PromotedDependency[]</code></td>
            
<td><code>0.13.6</code></td>
            
<td>A list of dependencies of both the old and new artifact(s) that
should be considered part of the old/new API. This is a convenience
property if you just need to specify a set of dependencies to
promote into the API and that set can be specified in a way common
to both old and new APIs. If you need to specify different sets for
the old and new, use <code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> respectively. If
<code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> are specified, they override
whatever is specified using this property. 

<p>The individual properties of the dependency (e.g.
<code>groupId</code>, <code>artifactId</code>,
<code>version</code>, <code>type</code> or <code>classifier</code>)
are matched exactly. If you enclose the value in forward slashes,
they are matched as regular expressions instead.</p>

<p>E.g. <code>&lt;groupId&gt;com.acme&lt;/groupId&gt;</code> will
only match dependencies with that exact <code>groupId</code>, while
<code>&lt;groupId&gt;/com\.acme(\..*)?/&lt;/groupId&gt;</code> will
match &quot;com.acme&quot; <code>groupId</code> or any &quot;sub-groupId&quot; thereof
(e.g. &quot;com.acme.utils&quot;, etc.) using a regular expression.</p><br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#reportCriticality">&lt;reportCriticality&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.5.0</code></td>
            
<td>The minimum criticality of the differences that should be included
in the report. This has to be one of the criticalities configured
in the pipeline configuration (if the pipeline configuration
doesn't define any, the following are the default ones:
<code>allowed</code>, <code>documented</code>,
<code>highlight</code>, <code>error</code>). If not defined, the
value is derived from <code>reportSeverity</code> using the
severity-to-criticality mapping (which is again configured in the
pipeline configuration. If not defined in the pipeline
configuration explicitly, the default mapping is the following:
<code>EQUIVALENT</code> = <code>allowed</code>,
<code>NON_BREAKING</code> = <code>documented</code>,
<code>POTENTIALLY_BREAKING</code> = <code>error</code>,
<code>BREAKING</code> = error.<br /><b>User property is</b>: <code>revapi.minimumCriticality</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#reportSeverity">&lt;reportSeverity&gt;</a></code></td>
            
<td><code>FailSeverity</code></td>
            
<td><code>0.5.0</code></td>
            
<td><b>Deprecated.</b> use <code>reportCriticality</code> instead<br /><b>Default value is</b>: <code>potentiallyBreaking</code>.<br /><b>User property is</b>: <code>revapi.reportSeverity</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#resolveProvidedDependencies">&lt;resolveProvidedDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>When establishing the API classes, Revapi by default also looks
through the <code>provided</code> dependencies. The reason for this
is that even though such dependencies do not appear in the
transitive dependency set established by maven, they need to be
present both on the compilation and runtime classpath of the
module. Therefore, the classes in the module are free to expose
classes from a provided dependency as API elements. 

<p>In rare circumstances this is not a desired behavior though. It
is undesired if for example the classes from the provided
dependency are used only for establishing desired build order or
when they are used in some non-standard scenarios during the build
and actually not needed at runtime.</p>

<p>Note that this property only influences the resolution of
provided dependencies of the main artifacts, not the transitively
reachable provided dependencies. For those, use the
<code>resolveTransitiveProvidedDependencies</code> parameter.</p><br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.resolveProvidedDependencies</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#resolveTransitiveProvidedDependencies">&lt;resolveTransitiveProvidedDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>In addition to <code>resolveProvidedDependencies</code> this
property further controls how provided dependencies are resolved.
Using this property you can control how the indirect, transitively
reachable, provided dependencies are treated. The default is to not
consider them, which is almost always the right thing to do. It
might be necessary to set this property to <code>true</code> in the
rare circumstances where the API of the main artifacts includes
types from such transitively included provided dependencies. Such
occurrence will manifest itself by Revapi considering such types as
missing (which is by default reported as a potentially breaking
change). When you then resolve the transitive provided dependencies
(by setting this parameter to true), Revapi will be able to find
such types and do a proper analysis of them.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.resolveTransitiveProvidedDependencies</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#skip">&lt;skip&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.5.0</code></td>
            
<td>Whether to skip the mojo execution.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.skip</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#versionFormat">&lt;versionFormat&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.5.0</code></td>
            
<td>If set, this property demands a format of the version string when
the <code>oldVersion</code> or <code>newVersion</code> parameters
are set to <code>RELEASE</code> or <code>LATEST</code> special
version strings. 

<p>Because Maven will report the newest non-snapshot version as the
latest release, we might end up comparing a <code>.Beta</code> or
other pre-release versions with the new version. This might not be
what you want and setting the versionFormat will make sure that a
newest version conforming to the version format is used instead of
the one resolved by Maven by default.</p>

<p>This parameter is a regular expression pattern that the version
string needs to match in order to be considered a
<code>RELEASE</code>.</p><br /><b>User property is</b>: <code>revapi.versionFormat</code>.<br /></td>
          </tr>
        </table>
      </section>
      <section>
<h3><a name="Parameter_Details"></a>Parameter Details</h3>
        <section>
<h4><a name="a.3CalwaysCheckForReleaseVersion.3E"></a><b><a name="alwaysCheckForReleaseVersion">&lt;alwaysCheckForReleaseVersion&gt;</a></b></h4>
        
<div>If true (the default) revapi will always download the information
about the latest version from the remote repositories (instead of
using locally cached info). This will respect the offline settings.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.alwaysCheckForReleaseVersion</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CanalysisConfiguration.3E"></a><b><a name="analysisConfiguration">&lt;analysisConfiguration&gt;</a></b></h4>
        
<div>The JSON or XML configuration of various analysis options. The
available options depend on what analyzers are present on the
plugin classpath through the <code>&lt;dependencies&gt;</code>.
Consult <a href="examples/configuration.html">configuration
documentation</a> for more details. 

<p>These settings take precedence over the configuration loaded
from <code>analysisConfigurationFiles</code>.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>org.codehaus.plexus.configuration.PlexusConfiguration</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CanalysisConfigurationFiles.3E"></a><b><a name="analysisConfigurationFiles">&lt;analysisConfigurationFiles&gt;</a></b></h4>
        
<div>The list of files containing the configuration of various analysis
options. The available options depend on what analyzers are present
on the plugins classpath through the
<code>&lt;dependencies&gt;</code>. 

<p>The <code>analysisConfiguration</code> can override the settings
present in the files.</p>

<p>The list is either a list of strings or has the following
form:</p>

<div>
<pre>
<code>
  &lt;analysisConfigurationFiles&gt;
       &lt;configurationFile&gt;
           &lt;path&gt;path/to/the/file/relative/to/project/base/dir&lt;/path&gt;
           &lt;resource&gt;path/to/the/file/in/one/of/the/dependencies&lt;/resource&gt;
           &lt;roots&gt;
               &lt;root&gt;configuration/root1&lt;/root&gt;
               &lt;root&gt;configuration/root2&lt;/root&gt;
               ...
           &lt;/roots&gt;
       &lt;/configurationFile&gt;
       ...
   &lt;/analysisConfigurationFiles&gt;
</code>
</pre></div>

where 

<ul>

<li><code>path</code> is the path on the filesystem,</li>

<li><code>resource</code> is the path to the resource file in one
of the artifacts the plugin depends on</li>

<li><code>roots</code> is optional and specifies the subtrees of
the JSON/XML config that should be used for configuration. If not
specified, the whole file is taken into account.</li>
</ul>
Either <code>path</code> or <code>resource</code> has to be
specified but not both. The <code>configuration/root1</code> and
<code>configuration/root2</code> are paths to the roots of the
configuration inside that JSON/XML config file. This might be used
in cases where multiple configurations are stored within a single
file and you want to use a particular one. 

<p>An example of this might be a config file which contains API
changes to be ignored in all past versions of a library. The
classes to be ignored are specified in a configuration that is
specific for each version:</p>

<div>
<pre>
<code>
   {
        &quot;0.1.0&quot; : [
            {
                &quot;extension&quot;: &quot;revapi.ignore&quot;,
                &quot;configuration&quot;: [
                    {
                        &quot;code&quot; : &quot;java.method.addedToInterface&quot;,
                        &quot;new&quot; : &quot;method void com.example.MyInterface::newMethod()&quot;,
                        &quot;justification&quot; : &quot;This interface is not supposed to be implemented by clients.&quot;
                    },
                    ...
                ]
            }
        ],
        &quot;0.2.0&quot; : [
            ...
        ]
    }
</code>
</pre></div></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.Object[]</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.analysisConfigurationFiles</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CcheckDependencies.3E"></a><b><a name="checkDependencies">&lt;checkDependencies&gt;</a></b></h4>
        
<div>Whether to include the dependencies in the API checks. This is the
default thing to do because your API might be exposing classes from
the dependencies and thus classes from your dependencies could
become part of your API. 

<p>However, setting this to false might be useful in situations
where you have checked your dependencies in another module and
don't want do that again. In that case, you might want to configure
Revapi to ignore missing classes because it might find the classes
from your dependencies as used in your API and would complain that
it could not find it. See <a class="externalLink" href="http://revapi.org/modules/revapi-java/extensions/java.html">the
docs</a>.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.checkDependencies</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CdisallowedExtensions.3E"></a><b><a name="disallowedExtensions">&lt;disallowedExtensions&gt;</a></b></h4>
        
<div>A comma-separated list of extensions (fully-qualified class names
thereof) that are not taken into account during API analysis. By
default, all extensions that are found on the classpath are used. 

<p>You can modify this set if you use another extensions that
change the found differences in a way that the determined new
version would not correspond to what it should be.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.disallowedExtensions</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CexpandProperties.3E"></a><b><a name="expandProperties">&lt;expandProperties&gt;</a></b></h4>
        
<div>If set to true, the Maven properties will be expanded in the
configuration before it is supplied to Revapi. I.e. any
<code>${var</code>} appearing in the configuration <b>values</b>
will be replaced with the value of the <code>var</code> property as
known to Maven. If the property is not defined, the expansion
doesn't take place.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.11.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.expandProperties</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailOnMissingConfigurationFiles.3E"></a><b><a name="failOnMissingConfigurationFiles">&lt;failOnMissingConfigurationFiles&gt;</a></b></h4>
        
<div>Set to false if you want to tolerate files referenced in the
<code>analysisConfigurationFiles</code> missing on the filesystem
and therefore not contributing to the analysis configuration. 

<p>The default is <code>true</code>, which means that a missing
analysis configuration file will fail the build.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failOnMissingConfigurationFiles</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailOnUnresolvedArtifacts.3E"></a><b><a name="failOnUnresolvedArtifacts">&lt;failOnUnresolvedArtifacts&gt;</a></b></h4>
        
<div>If true, the build will fail if one of the old or new artifacts
fails to be resolved. Defaults to false.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failOnUnresolvedArtifacts</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailOnUnresolvedDependencies.3E"></a><b><a name="failOnUnresolvedDependencies">&lt;failOnUnresolvedDependencies&gt;</a></b></h4>
        
<div>If true, the build will fail if some of the dependencies of the old
or new artifacts fail to be resolved. Defaults to false.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failOnUnresolvedDependencies</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CgenerateSiteReport.3E"></a><b><a name="generateSiteReport">&lt;generateSiteReport&gt;</a></b></h4>
        
<div>Set this to false if you want to use the goal to generate other
kind of output than the default report for the Maven-generated
site. You can generate such output by using different reporting
extensions (like revapi-reporter-text).</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.generateSiteReport</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CnewArtifacts.3E"></a><b><a name="newArtifacts">&lt;newArtifacts&gt;</a></b></h4>
        
<div>The coordinates of the new artifacts. These are the full GAVs of
the artifacts, which means that you can compare different artifacts
than the one being built. If you merely want to specify the
artifact being built, use <code>newVersion</code> property instead.</div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String[]</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.newArtifacts</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CnewPromotedDependencies.3E"></a><b><a name="newPromotedDependencies">&lt;newPromotedDependencies&gt;</a></b></h4>
        
<div>A list of dependencies of the new artifact(s) that should be
considered part of the new API.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.PromotedDependency[]</code></li>
          
<li><b>Since</b>: <code>0.13.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CnewVersion.3E"></a><b><a name="newVersion">&lt;newVersion&gt;</a></b></h4>
        
<div>The new version of the artifact. Defaults to &quot;${project.version}&quot;.</div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.newVersion</code></li>
          
<li><b>Default</b>: <code>${project.version}</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3ColdArtifacts.3E"></a><b><a name="oldArtifacts">&lt;oldArtifacts&gt;</a></b></h4>
        
<div>The coordinates of the old artifacts. Defaults to single artifact
with the latest released version of the current project. 

<p>If the this property is null, the <code>oldVersion</code>
property is checked for a value of the old version of the artifact
being built.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String[]</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.oldArtifacts</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3ColdPromotedDependencies.3E"></a><b><a name="oldPromotedDependencies">&lt;oldPromotedDependencies&gt;</a></b></h4>
        
<div>A list of dependencies of the old artifact(s) that should be
considered part of the old API.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.PromotedDependency[]</code></li>
          
<li><b>Since</b>: <code>0.13.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3ColdVersion.3E"></a><b><a name="oldVersion">&lt;oldVersion&gt;</a></b></h4>
        
<div>If you don't want to compare a different artifact than the one
being built, specifying the just the old version is simpler way of
specifying the old artifact. 

<p>The default value is &quot;RELEASE&quot; meaning that the old version is
the last released version of the artifact being built.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.oldVersion</code></li>
          
<li><b>Default</b>: <code>RELEASE</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CpipelineConfiguration.3E"></a><b><a name="pipelineConfiguration">&lt;pipelineConfiguration&gt;</a></b></h4>
        
<div>The JSON or XML configuration of the extensions pipeline. This
enables the users easily specify which extensions should be
included/excluded in the Revapi analysis pipeline and also to
define transformation blocks - a way of grouping transforms
together to enable more fine grained control over how differences
are transformed.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.codehaus.plexus.configuration.PlexusConfiguration</code></li>
          
<li><b>Since</b>: <code>0.11.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CpromotedDependencies.3E"></a><b><a name="promotedDependencies">&lt;promotedDependencies&gt;</a></b></h4>
        
<div>A list of dependencies of both the old and new artifact(s) that
should be considered part of the old/new API. This is a convenience
property if you just need to specify a set of dependencies to
promote into the API and that set can be specified in a way common
to both old and new APIs. If you need to specify different sets for
the old and new, use <code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> respectively. If
<code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> are specified, they override
whatever is specified using this property. 

<p>The individual properties of the dependency (e.g.
<code>groupId</code>, <code>artifactId</code>,
<code>version</code>, <code>type</code> or <code>classifier</code>)
are matched exactly. If you enclose the value in forward slashes,
they are matched as regular expressions instead.</p>

<p>E.g. <code>&lt;groupId&gt;com.acme&lt;/groupId&gt;</code> will
only match dependencies with that exact <code>groupId</code>, while
<code>&lt;groupId&gt;/com\.acme(\..*)?/&lt;/groupId&gt;</code> will
match &quot;com.acme&quot; <code>groupId</code> or any &quot;sub-groupId&quot; thereof
(e.g. &quot;com.acme.utils&quot;, etc.) using a regular expression.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.PromotedDependency[]</code></li>
          
<li><b>Since</b>: <code>0.13.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CreportCriticality.3E"></a><b><a name="reportCriticality">&lt;reportCriticality&gt;</a></b></h4>
        
<div>The minimum criticality of the differences that should be included
in the report. This has to be one of the criticalities configured
in the pipeline configuration (if the pipeline configuration
doesn't define any, the following are the default ones:
<code>allowed</code>, <code>documented</code>,
<code>highlight</code>, <code>error</code>). If not defined, the
value is derived from <code>reportSeverity</code> using the
severity-to-criticality mapping (which is again configured in the
pipeline configuration. If not defined in the pipeline
configuration explicitly, the default mapping is the following:
<code>EQUIVALENT</code> = <code>allowed</code>,
<code>NON_BREAKING</code> = <code>documented</code>,
<code>POTENTIALLY_BREAKING</code> = <code>error</code>,
<code>BREAKING</code> = error.</div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.minimumCriticality</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CreportSeverity.3E"></a><b><a name="reportSeverity">&lt;reportSeverity&gt;</a></b></h4>
        
<div><b>Deprecated.</b> use <code>reportCriticality</code> instead</div>
        
<div>Problems with this or higher severity will be included in the
report. Possible values: equivalent, nonBreaking,
potentiallyBreaking, breaking.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.FailSeverity</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.reportSeverity</code></li>
          
<li><b>Default</b>: <code>potentiallyBreaking</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CresolveProvidedDependencies.3E"></a><b><a name="resolveProvidedDependencies">&lt;resolveProvidedDependencies&gt;</a></b></h4>
        
<div>When establishing the API classes, Revapi by default also looks
through the <code>provided</code> dependencies. The reason for this
is that even though such dependencies do not appear in the
transitive dependency set established by maven, they need to be
present both on the compilation and runtime classpath of the
module. Therefore, the classes in the module are free to expose
classes from a provided dependency as API elements. 

<p>In rare circumstances this is not a desired behavior though. It
is undesired if for example the classes from the provided
dependency are used only for establishing desired build order or
when they are used in some non-standard scenarios during the build
and actually not needed at runtime.</p>

<p>Note that this property only influences the resolution of
provided dependencies of the main artifacts, not the transitively
reachable provided dependencies. For those, use the
<code>resolveTransitiveProvidedDependencies</code> parameter.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.resolveProvidedDependencies</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CresolveTransitiveProvidedDependencies.3E"></a><b><a name="resolveTransitiveProvidedDependencies">&lt;resolveTransitiveProvidedDependencies&gt;</a></b></h4>
        
<div>In addition to <code>resolveProvidedDependencies</code> this
property further controls how provided dependencies are resolved.
Using this property you can control how the indirect, transitively
reachable, provided dependencies are treated. The default is to not
consider them, which is almost always the right thing to do. It
might be necessary to set this property to <code>true</code> in the
rare circumstances where the API of the main artifacts includes
types from such transitively included provided dependencies. Such
occurrence will manifest itself by Revapi considering such types as
missing (which is by default reported as a potentially breaking
change). When you then resolve the transitive provided dependencies
(by setting this parameter to true), Revapi will be able to find
such types and do a proper analysis of them.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.resolveTransitiveProvidedDependencies</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3Cskip.3E"></a><b><a name="skip">&lt;skip&gt;</a></b></h4>
        
<div>Whether to skip the mojo execution.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.skip</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CversionFormat.3E"></a><b><a name="versionFormat">&lt;versionFormat&gt;</a></b></h4>
        
<div>If set, this property demands a format of the version string when
the <code>oldVersion</code> or <code>newVersion</code> parameters
are set to <code>RELEASE</code> or <code>LATEST</code> special
version strings. 

<p>Because Maven will report the newest non-snapshot version as the
latest release, we might end up comparing a <code>.Beta</code> or
other pre-release versions with the new version. This might not be
what you want and setting the versionFormat will make sure that a
newest version conforming to the version format is used instead of
the one resolved by Maven by default.</p>

<p>This parameter is a regular expression pattern that the version
string needs to match in order to be considered a
<code>RELEASE</code>.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.5.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.versionFormat</code></li>
        </ul>
      </section></section>
    </section>
  

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2014&#x2013;2022<a href="http://lukas.krejci.pw">Lukas Krejci</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
