<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VersionsTransform.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Basic Features</a> &gt; <a href="index.source.html" class="el_package">org.revapi.basic</a> &gt; <span class="el_source">VersionsTransform.java</span></div><h1>VersionsTransform.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2025 Lukas Krejci
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.revapi.basic;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;
import static java.util.Collections.singletonMap;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.fasterxml.jackson.databind.JsonNode;
import org.revapi.AnalysisContext;
import org.revapi.Archive;
import org.revapi.CompatibilityType;
import org.revapi.Criticality;
import org.revapi.Difference;
import org.revapi.DifferenceSeverity;
import org.revapi.Element;
import org.revapi.Reference;
import org.revapi.TransformationResult;
import org.revapi.base.BaseDifferenceTransform;

<span class="fc" id="L61">public class VersionsTransform&lt;E extends Element&lt;E&gt;&gt; extends BaseDifferenceTransform&lt;E&gt; {</span>
<span class="fc" id="L62">    private static final Pattern[] ALL_CODES = new Pattern[] { Pattern.compile(&quot;.*&quot;) };</span>
<span class="fc" id="L63">    private static final Pattern[] NO_CODES = new Pattern[0];</span>

    private boolean enabled;
    private List&lt;String&gt; passThroughDifferences;
    private VersionIncreaseConfig allowedInMajor;
    private VersionIncreaseConfig allowedInMinor;
    private VersionIncreaseConfig allowedInPatch;
    private VersionIncreaseConfig allowedInSuffix;
    private DifferenceModification allowedModify;
    private DifferenceModification disallowedModify;
    private Map&lt;String, VersionRecord&gt; archiveHints;

    private static DifferenceSeverity getMaxSeverity(Difference diff) {
<span class="fc" id="L76">        return diff.classification.values().stream().max(Comparator.comparingInt(Enum::ordinal))</span>
<span class="fc" id="L77">                .orElse(DifferenceSeverity.EQUIVALENT);</span>
    }

    @Override
    public Pattern[] getDifferenceCodePatterns() {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        return enabled ? ALL_CODES : NO_CODES;</span>
    }

    @Nonnull
    @Override
    public List&lt;Predicate&lt;String&gt;&gt; getDifferenceCodePredicates() {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        return enabled ? Collections.singletonList(__ -&gt; true) : Collections.emptyList();</span>
    }

    @Override
    public TransformationResult tryTransform(@Nullable E oldElement, @Nullable E newElement, Difference difference) {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L94">            return TransformationResult.keep();</span>
        }

<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (passThroughDifferences.contains(difference.code)) {</span>
<span class="nc" id="L98">            return TransformationResult.keep();</span>
        }

<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        Archive.Versioned oldArchive = (Archive.Versioned) (oldElement == null ? null : oldElement.getArchive());</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        Archive.Versioned newArchive = (Archive.Versioned) (newElement == null ? null : newElement.getArchive());</span>

<span class="fc" id="L104">        DifferenceSeverity maxSeverity = getMaxSeverity(difference);</span>

<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        Archive.Versioned decidingArchive = newArchive == null ? oldArchive : newArchive;</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (decidingArchive == null) {</span>
<span class="nc" id="L108">            throw new IllegalStateException(&quot;At least one of the archives must not be null when comparing elements &quot;</span>
                    + oldElement + &quot; and &quot; + newElement);
        }

        boolean allowed;
<span class="fc" id="L113">        VersionRecord versionRecord = archiveHints.get(decidingArchive.getBaseName());</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (versionRecord == null) {</span>
            // the difference was found in archives that are not part of the primary API (i.e. the element is in some
            // supplementary archive). We need to find all elements in the primary API and decide about the change
            // from the point of view of the archive of the with the smallest version change.

<span class="fc" id="L119">            Set&lt;Archive.Versioned&gt; primaryReferencingArchives = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if (newElement == null) {</span>
<span class="nc" id="L121">                getAllReferencingAPIElements(oldElement, primaryReferencingArchives, new HashSet&lt;&gt;());</span>
            } else {
<span class="fc" id="L123">                getAllReferencingAPIElements(newElement, primaryReferencingArchives, new HashSet&lt;&gt;());</span>
            }

<span class="fc" id="L126">            versionRecord = primaryReferencingArchives.stream().map(a -&gt; archiveHints.get(a.getBaseName())).reduce(null,</span>
                    (a, b) -&gt; {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">                        if (a == null) {</span>
<span class="fc" id="L129">                            return b;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                        } else if (b == null) {</span>
<span class="nc" id="L131">                            return a;</span>
                        } else {
<span class="nc bnc" id="L133" title="All 2 branches missed.">                            return a.versionChange.compareTo(b.versionChange) &gt; 0 ? b : a;</span>
                        }
                    });

<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (versionRecord == null) {</span>
                // this should really never happen, because we assume that any change in the supplementary archives
                // is only visible if there is a referencing element in the primary api. But let's just not throw any
                // exceptions and only communicate our findings to the user somehow.
<span class="fc" id="L141">                return TransformationResult.replaceWith(markUnhandled(difference));</span>
            }
        }

<span class="pc bpc" id="L145" title="5 of 7 branches missed.">        switch (versionRecord.versionChange) {</span>
        case NEW:
            // either this is a truly new element in a new primary API archive or an element that has moved from
            // a supplementary archive into a new primary API archive.
            // In either case, we can allow this change purely from a versioning perspective.
<span class="nc" id="L150">            allowed = true;</span>
<span class="nc" id="L151">            break;</span>
        case REMOVED:
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (newElement == null) {</span>
                // the original archive is no longer in the API, and the element was really removed, so this is allowed.
<span class="nc" id="L155">                allowed = true;</span>
            } else {
                // the archive disappeared but the element was moved to another archive. The only way this can happen
                // is that the element moved from a primary archives into a supplementary archive but is still exposed
                // in the API (it could not have been moved into a primary API archive, because we would have detected
                // that - the new archives take precedence when determining the change).
                //
                // But that would only be possible if the newElement didn't have an archive assigned - because otherwise
                // we would have found some archive for the new element. This case is not supported and we have to bail
                // somehow.
<span class="nc" id="L165">                return TransformationResult.replaceWith(markUnhandled(difference));</span>
            }
            break;
        case SUFFIX:
<span class="fc" id="L169">            allowed = allowedInSuffix.allows(versionRecord, difference, maxSeverity);</span>
<span class="fc" id="L170">            break;</span>
        case PATCH:
<span class="fc" id="L172">            allowed = allowedInPatch.allows(versionRecord, difference, maxSeverity);</span>
<span class="fc" id="L173">            break;</span>
        case MINOR:
<span class="nc" id="L175">            allowed = allowedInMinor.allows(versionRecord, difference, maxSeverity);</span>
<span class="nc" id="L176">            break;</span>
        case MAJOR:
<span class="nc" id="L178">            allowed = allowedInMajor.allows(versionRecord, difference, maxSeverity);</span>
<span class="nc" id="L179">            break;</span>
        default:
<span class="nc" id="L181">            throw new IllegalStateException(&quot;Unhandled version change kind: &quot; + versionRecord.versionChange);</span>
        }

<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (allowed) {</span>
<span class="fc" id="L185">            return allowedModify.modify(difference);</span>
        } else {
<span class="fc" id="L187">            return disallowedModify.modify(difference);</span>
        }
    }

    @Override
    public String getExtensionId() {
<span class="fc" id="L193">        return &quot;revapi.versions&quot;;</span>
    }

    @Nullable
    @Override
    public Reader getJSONSchema() {
<span class="nc" id="L199">        return new InputStreamReader(getClass().getResourceAsStream(&quot;/META-INF/versions-schema.json&quot;),</span>
                StandardCharsets.UTF_8);
    }

    @Override
    public void initialize(@Nonnull AnalysisContext analysisContext) {
<span class="fc" id="L205">        JsonNode config = analysisContext.getConfigurationNode();</span>

<span class="fc" id="L207">        enabled = config.path(&quot;enabled&quot;).asBoolean(false);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L209">            return;</span>
        }

<span class="fc" id="L212">        Map&lt;String, Archive.Versioned&gt; oldArchives = StreamSupport</span>
<span class="fc" id="L213">                .stream(analysisContext.getOldApi().getArchives().spliterator(), false).map(a -&gt; (Archive.Versioned) a)</span>
<span class="fc" id="L214">                .collect(Collectors.toMap(Archive.Versioned::getBaseName, identity()));</span>
<span class="fc" id="L215">        Map&lt;String, Archive.Versioned&gt; newArchives = StreamSupport</span>
<span class="fc" id="L216">                .stream(analysisContext.getNewApi().getArchives().spliterator(), false).map(a -&gt; (Archive.Versioned) a)</span>
<span class="fc" id="L217">                .collect(Collectors.toMap(Archive.Versioned::getBaseName, identity()));</span>

<span class="pc bpc" id="L219" title="2 of 4 branches missed.">        if (oldArchives.isEmpty() || newArchives.isEmpty()) {</span>
<span class="nc" id="L220">            enabled = false;</span>
<span class="nc" id="L221">            return;</span>
        }

<span class="fc" id="L224">        passThroughDifferences = StreamSupport.stream(config.path(&quot;passThroughDifferences&quot;).spliterator(), false)</span>
<span class="fc" id="L225">                .map(JsonNode::asText).collect(toList());</span>

<span class="fc" id="L227">        allowedInMajor = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L228">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;major&quot;));</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (allowedInMajor == null) {</span>
<span class="fc" id="L230">            allowedInMajor = VersionIncreaseConfig.DEFAULT_MAJOR;</span>
        }

<span class="fc" id="L233">        allowedInMinor = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L234">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;minor&quot;));</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (allowedInMinor == null) {</span>
<span class="fc" id="L236">            allowedInMinor = VersionIncreaseConfig.DEFAULT_MINOR;</span>
        }

<span class="fc" id="L239">        allowedInPatch = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L240">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;patch&quot;));</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (allowedInPatch == null) {</span>
<span class="fc" id="L242">            allowedInPatch = VersionIncreaseConfig.DEFAULT_PATCH;</span>
        }

<span class="fc" id="L245">        allowedInSuffix = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L246">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;suffix&quot;));</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (allowedInSuffix == null) {</span>
<span class="fc" id="L248">            allowedInSuffix = VersionIncreaseConfig.DEFAULT_SUFFIX;</span>
        }

<span class="fc" id="L251">        allowedModify = DifferenceModification.parseModify(analysisContext, config.path(&quot;onAllowed&quot;));</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (allowedModify == null) {</span>
<span class="fc" id="L253">            allowedModify = new DifferenceModification(emptyMap(), null, null, null,</span>
<span class="fc" id="L254">                    singletonMap(&quot;breaksVersioningRules&quot;, &quot;false&quot;));</span>
        }
<span class="fc" id="L256">        disallowedModify = DifferenceModification.parseModify(analysisContext, config.path(&quot;onDisallowed&quot;));</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (disallowedModify == null) {</span>
<span class="fc" id="L258">            Criticality breakingCriticality = analysisContext.getDefaultCriticality(DifferenceSeverity.BREAKING);</span>
<span class="fc" id="L259">            disallowedModify = new DifferenceModification(emptyMap(), breakingCriticality, null, null,</span>
<span class="fc" id="L260">                    singletonMap(&quot;breaksVersioningRules&quot;, &quot;true&quot;));</span>
        }

<span class="fc" id="L263">        boolean semantic0 = config.path(&quot;semantic0&quot;).asBoolean(true);</span>

<span class="fc" id="L265">        boolean strictSemver = config.path(&quot;strictSemver&quot;).asBoolean(true);</span>

        // now compute the change hints on the archives
<span class="fc" id="L268">        archiveHints = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (Map.Entry&lt;String, Archive.Versioned&gt; e : oldArchives.entrySet()) {</span>
<span class="fc" id="L270">            Archive.Versioned oldArchive = e.getValue();</span>
<span class="fc" id="L271">            Archive.Versioned newArchive = newArchives.remove(e.getKey());</span>

<span class="fc" id="L273">            SemverVersion oldVersion = SemverVersion.parse(oldArchive.getVersion(), strictSemver);</span>

<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if (newArchive == null) {</span>
                // the old archive is no longer part of the API and the classes from it are most probably part
                // of some other archive, possibly in the new API.
                // if we find some difference on some element from such archives, we can encounter:
                // 1) The old was removed (i.e. there is no counterpart anywhere in the new API)
                // 2) The old exists in other archive with some changes
                //
                // In the first case, we should not allow any severity on the old archive. In the second case,
                // we should decide on the semver result based on the version change of the new archive.
                //
                // Therefore, here we just assume the first case. The second case is automatically handled by
                // the fact that we prioritize the new element when looking for the archive in tryTransform().
<span class="nc" id="L287">                archiveHints.put(oldArchive.getBaseName(),</span>
                        new VersionRecord(oldArchive, null, oldVersion, null, VersionChange.REMOVED));
<span class="nc" id="L289">                continue;</span>
            }

<span class="fc" id="L292">            SemverVersion newVersion = SemverVersion.parse(newArchive.getVersion(), strictSemver);</span>

<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            boolean majorIncrease = oldVersion.major &lt; newVersion.major;</span>
<span class="pc bpc" id="L295" title="2 of 4 branches missed.">            boolean minorIncrease = oldVersion.major == newVersion.major &amp;&amp; oldVersion.minor &lt; newVersion.minor;</span>
<span class="pc bpc" id="L296" title="2 of 6 branches missed.">            boolean patchIncrease = oldVersion.major == newVersion.major &amp;&amp; oldVersion.minor == newVersion.minor</span>
                    &amp;&amp; oldVersion.patch &lt; newVersion.patch;
<span class="pc bpc" id="L298" title="2 of 6 branches missed.">            boolean suffixChange = oldVersion.major == newVersion.major &amp;&amp; oldVersion.minor == newVersion.minor</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">                    &amp;&amp; oldVersion.patch == newVersion.patch &amp;&amp; !Objects.equals(oldVersion.suffix, newVersion.suffix);</span>

            VersionChange versionChange;
<span class="pc bpc" id="L302" title="4 of 6 branches missed.">            if (semantic0 &amp;&amp; oldVersion.major == 0 &amp;&amp; !majorIncrease) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (minorIncrease) {</span>
<span class="nc" id="L304">                    versionChange = VersionChange.MAJOR;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                } else if (patchIncrease) {</span>
<span class="nc" id="L306">                    versionChange = VersionChange.MAJOR;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                } else if (suffixChange) {</span>
<span class="nc" id="L308">                    versionChange = VersionChange.MAJOR;</span>
                } else {
<span class="nc" id="L310">                    versionChange = VersionChange.NEW;</span>
                }
            } else {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">                if (majorIncrease) {</span>
<span class="nc" id="L314">                    versionChange = VersionChange.MAJOR;</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                } else if (minorIncrease) {</span>
<span class="nc" id="L316">                    versionChange = VersionChange.MINOR;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                } else if (patchIncrease) {</span>
<span class="fc" id="L318">                    versionChange = VersionChange.PATCH;</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                } else if (suffixChange) {</span>
<span class="fc" id="L320">                    versionChange = VersionChange.SUFFIX;</span>
                } else {
<span class="nc" id="L322">                    versionChange = VersionChange.NEW;</span>
                }
            }

<span class="fc" id="L326">            archiveHints.put(newArchive.getBaseName(),</span>
                    new VersionRecord(oldArchive, newArchive, oldVersion, newVersion, versionChange));
<span class="fc" id="L328">        }</span>

        // process the archives in the new API that are not present in the old API
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        for (Map.Entry&lt;String, Archive.Versioned&gt; e : newArchives.entrySet()) {</span>
<span class="nc" id="L332">            SemverVersion newVersion = SemverVersion.parse(e.getValue().getVersion(), strictSemver);</span>

            // There are again 2 cases of the element that we can encounter:
            // 1) The element is brand new (no counter part in any of the archives of the old API)
            // 2) The element has moved from another archive with changes
<span class="nc" id="L337">            archiveHints.put(e.getKey(), new VersionRecord(null, e.getValue(), null, newVersion, VersionChange.NEW));</span>
<span class="nc" id="L338">        }</span>

<span class="fc" id="L340">    }</span>

    private static Difference markUnhandled(Difference orig) {
<span class="fc" id="L343">        return Difference.copy(orig).addAttachment(&quot;breaksVersioningRules&quot;, &quot;unknown&quot;).build();</span>
    }

    private void getAllReferencingAPIElements(@Nullable E element, Set&lt;Archive.Versioned&gt; results, Set&lt;E&gt; processed) {
<span class="pc bpc" id="L347" title="2 of 4 branches missed.">        if (element == null || processed.contains(element)) {</span>
<span class="nc" id="L348">            return;</span>
        }

<span class="fc" id="L351">        processed.add(element);</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (element.getApi().getArchiveRole(element.getArchive()) == Archive.Role.PRIMARY) {</span>
<span class="fc" id="L354">            results.add((Archive.Versioned) element.getArchive());</span>
        }

<span class="fc" id="L357">        E parent = element.getParent();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L359">            getAllReferencingAPIElements(parent, results, processed);</span>
        }

<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (Reference&lt;E&gt; reference : element.getReferencingElements()) {</span>
<span class="fc" id="L363">            E el = reference.getElement();</span>
<span class="fc" id="L364">            getAllReferencingAPIElements(el, results, processed);</span>
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">    }</span>

    private static class VersionIncreaseConfig {
<span class="fc" id="L369">        static final VersionIncreaseConfig DEFAULT_MAJOR = new VersionIncreaseConfig(singletonList(new IncreaseAllows(</span>
<span class="fc" id="L370">                false, SeverityCheck.BREAKING, null, null, null, emptyMap(), emptyMap(), emptyList(), null, null)));</span>
<span class="fc" id="L371">        static final VersionIncreaseConfig DEFAULT_MINOR = new VersionIncreaseConfig(</span>
<span class="fc" id="L372">                singletonList(new IncreaseAllows(false, SeverityCheck.NON_BREAKING, null, null, null, emptyMap(),</span>
<span class="fc" id="L373">                        emptyMap(), emptyList(), null, null)));;</span>
<span class="fc" id="L374">        static final VersionIncreaseConfig DEFAULT_PATCH = new VersionIncreaseConfig(singletonList(new IncreaseAllows(</span>
<span class="fc" id="L375">                false, SeverityCheck.EQUIVALENT, null, null, null, emptyMap(), emptyMap(), emptyList(), null, null)));;</span>
<span class="fc" id="L376">        static final VersionIncreaseConfig DEFAULT_SUFFIX = new VersionIncreaseConfig(singletonList(new IncreaseAllows(</span>
<span class="fc" id="L377">                false, SeverityCheck.EQUIVALENT, null, null, null, emptyMap(), emptyMap(), emptyList(), null, null)));;</span>

        final List&lt;IncreaseAllows&gt; allows;

        static @Nullable VersionIncreaseConfig parse(AnalysisContext ctx, JsonNode node) {
<span class="fc bfc" id="L382" title="All 2 branches covered.">            if (node.isMissingNode()) {</span>
<span class="fc" id="L383">                return null;</span>
            }

<span class="fc" id="L386">            List&lt;IncreaseAllows&gt; parsedAllows = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">            if (node.isObject()) {</span>
<span class="fc" id="L388">                parsedAllows.add(parseAllows(ctx, node));</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            } else if (node.isArray()) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                for (JsonNode allows : node) {</span>
<span class="nc" id="L391">                    IncreaseAllows a = parseAllows(ctx, allows);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    if (a != null) {</span>
<span class="nc" id="L393">                        parsedAllows.add(a);</span>
                    }
<span class="nc" id="L395">                }</span>
            } else {
<span class="nc" id="L397">                throw new IllegalArgumentException(</span>
                        &quot;Expecting an object or array when specifying the allowed changes in a version increase.&quot;);
            }

<span class="fc" id="L401">            return new VersionIncreaseConfig(parsedAllows);</span>
        }

        private static @Nullable IncreaseAllows parseAllows(AnalysisContext ctx, JsonNode node) {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            if (!node.isObject()) {</span>
<span class="nc" id="L406">                return null;</span>
            }

<span class="fc" id="L409">            boolean regex = node.path(&quot;regex&quot;).asBoolean(false);</span>
            @Nullable
<span class="fc" id="L411">            String severity = node.path(&quot;severity&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L413">            String criticality = node.path(&quot;criticality&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L415">            String code = node.path(&quot;code&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L417">            String justification = node.path(&quot;justification&quot;).asText(null);</span>
<span class="fc" id="L418">            Map&lt;String, String&gt; attachments = new HashMap&lt;&gt;();</span>
<span class="fc" id="L419">            Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; it = node.path(&quot;attachments&quot;).fields();</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L421">                Map.Entry&lt;String, JsonNode&gt; entry = it.next();</span>
<span class="fc" id="L422">                attachments.put(entry.getKey(), entry.getValue().asText());</span>
<span class="fc" id="L423">            }</span>

<span class="fc" id="L425">            Map&lt;CompatibilityType, DifferenceSeverity&gt; classification = new EnumMap&lt;&gt;(CompatibilityType.class);</span>
<span class="fc" id="L426">            it = node.path(&quot;classification&quot;).fields();</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L428">                Map.Entry&lt;String, JsonNode&gt; entry = it.next();</span>
<span class="fc" id="L429">                classification.put(CompatibilityType.valueOf(entry.getKey()),</span>
<span class="fc" id="L430">                        DifferenceSeverity.valueOf(entry.getValue().asText()));</span>
<span class="fc" id="L431">            }</span>

            @Nullable
<span class="fc" id="L434">            String oldSuffix = node.path(&quot;old&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L436">            String newSuffix = node.path(&quot;new&quot;).asText(null);</span>

<span class="fc" id="L438">            List&lt;String&gt; inArchives = StreamSupport.stream(node.path(&quot;inArchives&quot;).spliterator(), false)</span>
<span class="fc" id="L439">                    .map(JsonNode::asText).collect(toList());</span>

<span class="fc bfc" id="L441" title="All 2 branches covered.">            return new IncreaseAllows(regex, severity == null ? null : SeverityCheck.valueOf(severity),</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">                    criticality == null ? null : ctx.getCriticalityByName(criticality), code, justification,</span>
                    attachments, classification, inArchives, oldSuffix, newSuffix);
        }

<span class="fc" id="L446">        VersionIncreaseConfig(List&lt;IncreaseAllows&gt; allows) {</span>
<span class="fc" id="L447">            this.allows = allows;</span>
<span class="fc" id="L448">        }</span>

        boolean allows(VersionRecord versionRecord, Difference difference, DifferenceSeverity maxSeverity) {
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">            return allows.stream().reduce(false, (a, b) -&gt; a || b.allows(versionRecord, difference, maxSeverity),</span>
                    Boolean::logicalOr);
        }
    }

    private static class IncreaseAllows {
        final @Nullable SeverityCheck severity;
        final @Nullable Criticality criticality;
        final @Nullable Pattern code;
        final @Nullable Pattern justification;
        final Map&lt;String, Pattern&gt; attachments;
        final Map&lt;CompatibilityType, DifferenceSeverity&gt; classification;
        final List&lt;Pattern&gt; inArchives;
        final @Nullable Pattern oldSuffix;
        final @Nullable Pattern newSuffix;

        private IncreaseAllows(boolean regex, @Nullable SeverityCheck severity, @Nullable Criticality criticality,
                @Nullable String code, @Nullable String justification, Map&lt;String, String&gt; attachments,
                Map&lt;CompatibilityType, DifferenceSeverity&gt; classification, List&lt;String&gt; inArchives,
<span class="fc" id="L470">                @Nullable String oldSuffix, @Nullable String newSuffix) {</span>
<span class="fc" id="L471">            this.severity = severity;</span>
<span class="fc" id="L472">            this.criticality = criticality;</span>
<span class="fc bfc" id="L473" title="All 4 branches covered.">            this.code = code == null ? null : Pattern.compile(regex ? code : Pattern.quote(code));</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            this.justification = justification == null ? null</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">                    : Pattern.compile(regex ? justification : Pattern.quote(justification));</span>
<span class="fc" id="L476">            this.attachments = attachments.entrySet().stream().collect(</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">                    toMap(Map.Entry::getKey, e -&gt; Pattern.compile(regex ? e.getValue() : Pattern.quote(e.getValue()))));</span>
<span class="fc" id="L478">            this.classification = classification;</span>
<span class="pc bnc" id="L479" title="All 2 branches missed.">            this.inArchives = inArchives.stream().map(a -&gt; Pattern.compile(regex ? a : Pattern.quote(a)))</span>
<span class="fc" id="L480">                    .collect(toList());</span>
<span class="pc bpc" id="L481" title="1 of 4 branches missed.">            this.oldSuffix = oldSuffix == null ? null : Pattern.compile(regex ? oldSuffix : Pattern.quote(oldSuffix));</span>
<span class="pc bpc" id="L482" title="1 of 4 branches missed.">            this.newSuffix = newSuffix == null ? null : Pattern.compile(regex ? newSuffix : Pattern.quote(newSuffix));</span>
<span class="fc" id="L483">        }</span>

        boolean allows(VersionRecord versionRecord, Difference difference, DifferenceSeverity maxSeverity) {

<span class="pc bpc" id="L487" title="3 of 4 branches missed.">            if (versionRecord.oldArchive == null &amp;&amp; versionRecord.newArchive == null) {</span>
<span class="nc" id="L488">                throw new IllegalStateException(&quot;At least one of the archives must be non-null.&quot;);</span>
            }

            // first we need to match the additional criteria on the archive
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            if (!inArchives.isEmpty()) {</span>
<span class="nc bnc" id="L493" title="All 4 branches missed.">                if (inArchives.stream().noneMatch(p -&gt; p.matcher(versionRecord.newArchive == null</span>
<span class="nc" id="L494">                        ? versionRecord.oldArchive.getBaseName() : versionRecord.newArchive.getBaseName()).matches())) {</span>
<span class="nc" id="L495">                    return false;</span>
                }
            }

<span class="fc bfc" id="L499" title="All 2 branches covered.">            if (this.oldSuffix != null) {</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                if (versionRecord.oldVersion == null) {</span>
<span class="nc" id="L501">                    return false;</span>
                } else {
<span class="fc" id="L503">                    String suffix = versionRecord.oldVersion.suffix;</span>
<span class="pc bpc" id="L504" title="2 of 4 branches missed.">                    if (!oldSuffix.matcher(suffix == null ? &quot;&quot; : suffix).matches()) {</span>
<span class="nc" id="L505">                        return false;</span>
                    }
                }
            }

<span class="fc bfc" id="L510" title="All 2 branches covered.">            if (this.newSuffix != null) {</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">                if (versionRecord.newVersion == null) {</span>
<span class="nc" id="L512">                    return false;</span>
                } else {
<span class="fc" id="L514">                    String suffix = versionRecord.newVersion.suffix;</span>
<span class="pc bpc" id="L515" title="2 of 4 branches missed.">                    if (!newSuffix.matcher(suffix == null ? &quot;&quot; : suffix).matches()) {</span>
<span class="nc" id="L516">                        return false;</span>
                    }
                }
            }

            // now we can check the difference

<span class="fc bfc" id="L523" title="All 4 branches covered.">            if (this.severity != null &amp;&amp; !this.severity.allows(maxSeverity)) {</span>
<span class="fc" id="L524">                return false;</span>
            }

<span class="pc bpc" id="L527" title="1 of 4 branches missed.">            if (this.criticality != null &amp;&amp; difference.criticality != null</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                    &amp;&amp; this.criticality.getLevel() &lt; difference.criticality.getLevel()) {</span>
<span class="fc" id="L529">                return false;</span>
            }

<span class="fc bfc" id="L532" title="All 4 branches covered.">            if (this.code != null &amp;&amp; !this.code.matcher(difference.code).matches()) {</span>
<span class="fc" id="L533">                return false;</span>
            }

<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (this.justification != null &amp;&amp; !this.justification</span>
<span class="pc bpc" id="L537" title="1 of 4 branches missed.">                    .matcher(difference.justification == null ? &quot;&quot; : difference.justification).matches()) {</span>
<span class="fc" id="L538">                return false;</span>
            }

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if (this.attachments != null) {</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                for (Map.Entry&lt;String, Pattern&gt; e : attachments.entrySet()) {</span>
<span class="fc" id="L543">                    String key = e.getKey();</span>
<span class="fc" id="L544">                    Pattern pattern = e.getValue();</span>

<span class="fc" id="L546">                    String value = difference.attachments.get(key);</span>

<span class="fc bfc" id="L548" title="All 4 branches covered.">                    if (!pattern.matcher(value == null ? &quot;&quot; : value).matches()) {</span>
<span class="fc" id="L549">                        return false;</span>
                    }
<span class="fc" id="L551">                }</span>
            }

<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            if (this.classification != null) {</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">                for (Map.Entry&lt;CompatibilityType, DifferenceSeverity&gt; e : classification.entrySet()) {</span>
<span class="fc" id="L556">                    DifferenceSeverity expected = e.getValue();</span>
<span class="fc" id="L557">                    DifferenceSeverity actual = difference.classification.get(e.getKey());</span>
<span class="pc bpc" id="L558" title="1 of 4 branches missed.">                    if (actual != null &amp;&amp; expected.compareTo(actual) &lt; 0) {</span>
<span class="fc" id="L559">                        return false;</span>
                    }
<span class="fc" id="L561">                }</span>
            }

<span class="fc" id="L564">            return true;</span>
        }
    }

    private static class DifferenceModification {
        final Map&lt;CompatibilityType, DifferenceSeverity&gt; classification;
        final @Nullable Criticality criticality;
        final @Nullable TextModification justification;
        final @Nullable TextModification description;
        final Map&lt;String, String&gt; attachments;
        final boolean remove;

        private static @Nullable DifferenceModification parseModify(AnalysisContext ctx, JsonNode node) {
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (node.isMissingNode()) {</span>
<span class="fc" id="L578">                return null;</span>
            }

<span class="fc bfc" id="L581" title="All 2 branches covered.">            if (node.path(&quot;remove&quot;).asBoolean(false)) {</span>
<span class="fc" id="L582">                return new DifferenceModification();</span>
            }

<span class="fc" id="L585">            JsonNode classificationNode = node.path(&quot;classification&quot;);</span>
<span class="fc" id="L586">            Map&lt;CompatibilityType, DifferenceSeverity&gt; classification = new EnumMap&lt;&gt;(CompatibilityType.class);</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">            if (classificationNode.has(&quot;SOURCE&quot;)) {</span>
<span class="nc" id="L588">                classification.put(CompatibilityType.SOURCE,</span>
<span class="nc" id="L589">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;SOURCE&quot;).asText()));</span>
            }
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">            if (classificationNode.has(&quot;BINARY&quot;)) {</span>
<span class="nc" id="L592">                classification.put(CompatibilityType.BINARY,</span>
<span class="nc" id="L593">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;BINARY&quot;).asText()));</span>
            }
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">            if (classificationNode.has(&quot;SEMANTIC&quot;)) {</span>
<span class="nc" id="L596">                classification.put(CompatibilityType.SEMANTIC,</span>
<span class="nc" id="L597">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;SEMANTIC&quot;).asText()));</span>
            }
<span class="fc bfc" id="L599" title="All 2 branches covered.">            if (classificationNode.has(&quot;OTHER&quot;)) {</span>
<span class="fc" id="L600">                classification.put(CompatibilityType.OTHER,</span>
<span class="fc" id="L601">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;OTHER&quot;).asText()));</span>
            }

            Criticality criticality;
<span class="fc bfc" id="L605" title="All 2 branches covered.">            if (!node.path(&quot;criticality&quot;).isMissingNode()) {</span>
<span class="fc" id="L606">                criticality = ctx.getCriticalityByName(node.path(&quot;criticality&quot;).asText());</span>
            } else {
<span class="fc" id="L608">                criticality = null;</span>
            }

<span class="fc" id="L611">            TextModification justification = parseTextModification(node.path(&quot;justification&quot;));</span>
<span class="fc" id="L612">            TextModification description = parseTextModification(node.path(&quot;description&quot;));</span>

<span class="fc" id="L614">            JsonNode attachmentsNode = node.path(&quot;attachments&quot;);</span>
<span class="fc" id="L615">            Map&lt;String, String&gt; attachments = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            if (!attachmentsNode.isMissingNode()) {</span>
<span class="fc" id="L617">                Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; it = attachmentsNode.fields();</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L619">                    Map.Entry&lt;String, JsonNode&gt; entry = it.next();</span>
<span class="fc" id="L620">                    attachments.put(entry.getKey(), entry.getValue().asText());</span>
<span class="fc" id="L621">                }</span>
            }

<span class="fc" id="L624">            return new DifferenceModification(classification, criticality, justification, description, attachments);</span>
        }

        @Nullable
        private static TextModification parseTextModification(JsonNode modificationNode) {
<span class="fc bfc" id="L629" title="All 2 branches covered.">            if (modificationNode.isTextual()) {</span>
<span class="fc" id="L630">                return new TextModification(modificationNode.asText(), null, null);</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">            } else if (modificationNode.isObject()) {</span>
<span class="fc" id="L632">                String prepend = modificationNode.path(&quot;prepend&quot;).asText();</span>
<span class="fc" id="L633">                String append = modificationNode.path(&quot;append&quot;).asText();</span>
<span class="fc" id="L634">                return new TextModification(null, prepend, append);</span>
            } else {
<span class="fc" id="L636">                return null;</span>
            }
        }

<span class="fc" id="L640">        private DifferenceModification() {</span>
<span class="fc" id="L641">            this.remove = true;</span>
<span class="fc" id="L642">            this.classification = emptyMap();</span>
<span class="fc" id="L643">            this.criticality = null;</span>
<span class="fc" id="L644">            this.justification = null;</span>
<span class="fc" id="L645">            this.description = null;</span>
<span class="fc" id="L646">            this.attachments = null;</span>
<span class="fc" id="L647">        }</span>

        private DifferenceModification(Map&lt;CompatibilityType, DifferenceSeverity&gt; classification,
                @Nullable Criticality criticality, @Nullable TextModification justification,
<span class="fc" id="L651">                @Nullable TextModification description, Map&lt;String, String&gt; attachments) {</span>
<span class="fc" id="L652">            this.classification = classification;</span>
<span class="fc" id="L653">            this.criticality = criticality;</span>
<span class="fc" id="L654">            this.justification = justification;</span>
<span class="fc" id="L655">            this.description = description;</span>
<span class="fc" id="L656">            this.attachments = attachments;</span>
<span class="fc" id="L657">            this.remove = false;</span>
<span class="fc" id="L658">        }</span>

        TransformationResult modify(Difference difference) {
<span class="fc bfc" id="L661" title="All 2 branches covered.">            if (remove) {</span>
<span class="fc" id="L662">                return TransformationResult.discard();</span>
            }

<span class="fc" id="L665">            Difference.Builder bld = Difference.copy(difference);</span>
<span class="fc" id="L666">            boolean changed = false;</span>

<span class="fc bfc" id="L668" title="All 2 branches covered.">            if (!classification.isEmpty()) {</span>
<span class="fc" id="L669">                changed = true;</span>
<span class="fc" id="L670">                bld.addClassifications(classification);</span>
            }

<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (criticality != null) {</span>
<span class="fc" id="L674">                changed = true;</span>
<span class="fc" id="L675">                bld.withCriticality(criticality);</span>
            }

<span class="fc bfc" id="L678" title="All 2 branches covered.">            if (justification != null) {</span>
<span class="fc" id="L679">                changed = true;</span>
<span class="fc" id="L680">                bld.withJustification(justification.apply(difference.justification));</span>
            }

<span class="fc bfc" id="L683" title="All 2 branches covered.">            if (description != null) {</span>
<span class="fc" id="L684">                changed = true;</span>
<span class="fc" id="L685">                bld.withDescription(description.apply(difference.description));</span>
            }

<span class="fc bfc" id="L688" title="All 2 branches covered.">            if (!attachments.isEmpty()) {</span>
<span class="fc" id="L689">                changed = true;</span>
<span class="fc" id="L690">                bld.addAttachments(attachments);</span>
            }

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">            if (changed) {</span>
<span class="fc" id="L694">                Difference newDiff = bld.build();</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                if (newDiff.equals(difference)) {</span>
<span class="fc" id="L696">                    return TransformationResult.keep();</span>
                } else {
<span class="fc" id="L698">                    return TransformationResult.replaceWith(bld.build());</span>
                }
            } else {
<span class="nc" id="L701">                return TransformationResult.keep();</span>
            }
        }
    }

<span class="fc" id="L706">    private enum SeverityCheck {</span>
<span class="fc" id="L707">        NONE, EQUIVALENT, NON_BREAKING, POTENTIALLY_BREAKING, BREAKING;</span>

        boolean allows(DifferenceSeverity severity) {
<span class="fc bfc" id="L710" title="All 2 branches covered.">            return this.ordinal() &gt;= severity.ordinal() + 1;</span>
        }
    }

    private static class TextModification {
        final @Nullable String value;
        final @Nullable String prepend;
        final @Nullable String append;

<span class="fc" id="L719">        private TextModification(@Nullable String value, @Nullable String prepend, @Nullable String append) {</span>
<span class="fc" id="L720">            this.value = value;</span>
<span class="fc" id="L721">            this.prepend = prepend;</span>
<span class="fc" id="L722">            this.append = append;</span>
<span class="fc" id="L723">        }</span>

        @Nullable
        String apply(@Nullable String value) {
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (this.value != null) {</span>
<span class="fc" id="L728">                value = this.value;</span>
            }

<span class="fc bfc" id="L731" title="All 2 branches covered.">            if (this.prepend != null) {</span>
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L733">                    value = this.prepend;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                } else if (!value.startsWith(this.prepend)) {</span>
<span class="fc" id="L735">                    value = this.prepend + value;</span>
                }
            }

<span class="fc bfc" id="L739" title="All 2 branches covered.">            if (this.append != null) {</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L741">                    value = this.append;</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">                } else if (!value.endsWith(this.append)) {</span>
<span class="fc" id="L743">                    value = value + this.append;</span>
                }
            }

<span class="fc" id="L747">            return value;</span>
        }
    }

    private static final class VersionRecord {
        final @Nullable Archive.Versioned oldArchive;
        final @Nullable Archive.Versioned newArchive;
        final @Nullable SemverVersion oldVersion;
        final @Nullable SemverVersion newVersion;
        final VersionChange versionChange;

        VersionRecord(@Nullable Archive.Versioned oldArchive, @Nullable Archive.Versioned newArchive,
<span class="fc" id="L759">                @Nullable SemverVersion oldVersion, @Nullable SemverVersion newVersion, VersionChange versionChange) {</span>
<span class="fc" id="L760">            this.oldArchive = oldArchive;</span>
<span class="fc" id="L761">            this.newArchive = newArchive;</span>
<span class="fc" id="L762">            this.oldVersion = oldVersion;</span>
<span class="fc" id="L763">            this.newVersion = newVersion;</span>
<span class="fc" id="L764">            this.versionChange = versionChange;</span>
<span class="fc" id="L765">        }</span>
    }

<span class="fc" id="L768">    private enum VersionChange {</span>
<span class="fc" id="L769">        REMOVED, NEW, SUFFIX, PATCH, MINOR, MAJOR;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>