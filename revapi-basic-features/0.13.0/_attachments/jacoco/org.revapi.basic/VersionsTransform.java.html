<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VersionsTransform.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Basic Features</a> &gt; <a href="index.source.html" class="el_package">org.revapi.basic</a> &gt; <span class="el_source">VersionsTransform.java</span></div><h1>VersionsTransform.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2022 Lukas Krejci
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.revapi.basic;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;
import static java.util.Collections.singletonMap;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.fasterxml.jackson.databind.JsonNode;
import org.revapi.AnalysisContext;
import org.revapi.Archive;
import org.revapi.CompatibilityType;
import org.revapi.Criticality;
import org.revapi.Difference;
import org.revapi.DifferenceSeverity;
import org.revapi.Element;
import org.revapi.Reference;
import org.revapi.TransformationResult;
import org.revapi.base.BaseDifferenceTransform;

<span class="fc" id="L59">public class VersionsTransform&lt;E extends Element&lt;E&gt;&gt; extends BaseDifferenceTransform&lt;E&gt; {</span>
<span class="fc" id="L60">    private static final Pattern[] ALL_CODES = new Pattern[] { Pattern.compile(&quot;.*&quot;) };</span>
<span class="fc" id="L61">    private static final Pattern[] NO_CODES = new Pattern[0];</span>

    private boolean enabled;
    private List&lt;String&gt; passThroughDifferences;
    private VersionIncreaseConfig allowedInMajor;
    private VersionIncreaseConfig allowedInMinor;
    private VersionIncreaseConfig allowedInPatch;
    private VersionIncreaseConfig allowedInSuffix;
    private DifferenceModification allowedModify;
    private DifferenceModification disallowedModify;
    private Map&lt;String, VersionRecord&gt; archiveHints;

    private static DifferenceSeverity getMaxSeverity(Difference diff) {
<span class="fc" id="L74">        return diff.classification.values().stream().max(Comparator.comparingInt(Enum::ordinal))</span>
<span class="fc" id="L75">                .orElse(DifferenceSeverity.EQUIVALENT);</span>
    }

    @Override
    public Pattern[] getDifferenceCodePatterns() {
<span class="nc bnc" id="L80" title="All 2 branches missed.">        return enabled ? ALL_CODES : NO_CODES;</span>
    }

    @Override
    public TransformationResult tryTransform(@Nullable E oldElement, @Nullable E newElement, Difference difference) {
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L86">            return TransformationResult.keep();</span>
        }

<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (passThroughDifferences.contains(difference.code)) {</span>
<span class="nc" id="L90">            return TransformationResult.keep();</span>
        }

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        Archive.Versioned oldArchive = (Archive.Versioned) (oldElement == null ? null : oldElement.getArchive());</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        Archive.Versioned newArchive = (Archive.Versioned) (newElement == null ? null : newElement.getArchive());</span>

<span class="fc" id="L96">        DifferenceSeverity maxSeverity = getMaxSeverity(difference);</span>

<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        Archive.Versioned decidingArchive = newArchive == null ? oldArchive : newArchive;</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (decidingArchive == null) {</span>
<span class="nc" id="L100">            throw new IllegalStateException(&quot;At least one of the archives must not be null when comparing elements &quot;</span>
                    + oldElement + &quot; and &quot; + newElement);
        }

        boolean allowed;
<span class="fc" id="L105">        VersionRecord versionRecord = archiveHints.get(decidingArchive.getBaseName());</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (versionRecord == null) {</span>
            // the difference was found in archives that are not part of the primary API (i.e. the element is in some
            // supplementary archive). We need to find all elements in the primary API and decide about the change
            // from the point of view of the archive of the with the smallest version change.

<span class="fc" id="L111">            Set&lt;Archive.Versioned&gt; primaryReferencingArchives = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (newElement == null) {</span>
<span class="nc" id="L113">                getAllReferencingAPIElements(oldElement, primaryReferencingArchives, new HashSet&lt;&gt;());</span>
            } else {
<span class="fc" id="L115">                getAllReferencingAPIElements(newElement, primaryReferencingArchives, new HashSet&lt;&gt;());</span>
            }

<span class="fc" id="L118">            versionRecord = primaryReferencingArchives.stream().map(a -&gt; archiveHints.get(a.getBaseName())).reduce(null,</span>
                    (a, b) -&gt; {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">                        if (a == null) {</span>
<span class="fc" id="L121">                            return b;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                        } else if (b == null) {</span>
<span class="nc" id="L123">                            return a;</span>
                        } else {
<span class="nc bnc" id="L125" title="All 2 branches missed.">                            return a.versionChange.compareTo(b.versionChange) &gt; 0 ? b : a;</span>
                        }
                    });

<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (versionRecord == null) {</span>
                // this should really never happen, because we assume that any change in the supplementary archives
                // is only visible if there is a referencing element in the primary api. But let's just not throw any
                // exceptions and only communicate our findings to the user somehow.
<span class="fc" id="L133">                return TransformationResult.replaceWith(markUnhandled(difference));</span>
            }
        }

<span class="pc bpc" id="L137" title="5 of 7 branches missed.">        switch (versionRecord.versionChange) {</span>
        case NEW:
            // either this is a truly new element in a new primary API archive or an element that has moved from
            // a supplementary archive into a new primary API archive.
            // In either case, we can allow this change purely from a versioning perspective.
<span class="nc" id="L142">            allowed = true;</span>
<span class="nc" id="L143">            break;</span>
        case REMOVED:
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (newElement == null) {</span>
                // the original archive is no longer in the API, and the element was really removed, so this is allowed.
<span class="nc" id="L147">                allowed = true;</span>
            } else {
                // the archive disappeared but the element was moved to another archive. The only way this can happen
                // is that the element moved from a primary archives into a supplementary archive but is still exposed
                // in the API (it could not have been moved into a primary API archive, because we would have detected
                // that - the new archives take precedence when determining the change).
                //
                // But that would only be possible if the newElement didn't have an archive assigned - because otherwise
                // we would have found some archive for the new element. This case is not supported and we have to bail
                // somehow.
<span class="nc" id="L157">                return TransformationResult.replaceWith(markUnhandled(difference));</span>
            }
            break;
        case SUFFIX:
<span class="fc" id="L161">            allowed = allowedInSuffix.allows(versionRecord, difference, maxSeverity);</span>
<span class="fc" id="L162">            break;</span>
        case PATCH:
<span class="fc" id="L164">            allowed = allowedInPatch.allows(versionRecord, difference, maxSeverity);</span>
<span class="fc" id="L165">            break;</span>
        case MINOR:
<span class="nc" id="L167">            allowed = allowedInMinor.allows(versionRecord, difference, maxSeverity);</span>
<span class="nc" id="L168">            break;</span>
        case MAJOR:
<span class="nc" id="L170">            allowed = allowedInMajor.allows(versionRecord, difference, maxSeverity);</span>
<span class="nc" id="L171">            break;</span>
        default:
<span class="nc" id="L173">            throw new IllegalStateException(&quot;Unhandled version change kind: &quot; + versionRecord.versionChange);</span>
        }

<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (allowed) {</span>
<span class="fc" id="L177">            return allowedModify.modify(difference);</span>
        } else {
<span class="fc" id="L179">            return disallowedModify.modify(difference);</span>
        }
    }

    @Override
    public String getExtensionId() {
<span class="fc" id="L185">        return &quot;revapi.versions&quot;;</span>
    }

    @Nullable
    @Override
    public Reader getJSONSchema() {
<span class="nc" id="L191">        return new InputStreamReader(getClass().getResourceAsStream(&quot;/META-INF/versions-schema.json&quot;),</span>
                StandardCharsets.UTF_8);
    }

    @Override
    public void initialize(@Nonnull AnalysisContext analysisContext) {
<span class="fc" id="L197">        JsonNode config = analysisContext.getConfigurationNode();</span>

<span class="fc" id="L199">        enabled = config.path(&quot;enabled&quot;).asBoolean(false);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L201">            return;</span>
        }

<span class="fc" id="L204">        Map&lt;String, Archive.Versioned&gt; oldArchives = StreamSupport</span>
<span class="fc" id="L205">                .stream(analysisContext.getOldApi().getArchives().spliterator(), false).map(a -&gt; (Archive.Versioned) a)</span>
<span class="fc" id="L206">                .collect(Collectors.toMap(Archive.Versioned::getBaseName, identity()));</span>
<span class="fc" id="L207">        Map&lt;String, Archive.Versioned&gt; newArchives = StreamSupport</span>
<span class="fc" id="L208">                .stream(analysisContext.getNewApi().getArchives().spliterator(), false).map(a -&gt; (Archive.Versioned) a)</span>
<span class="fc" id="L209">                .collect(Collectors.toMap(Archive.Versioned::getBaseName, identity()));</span>

<span class="pc bpc" id="L211" title="2 of 4 branches missed.">        if (oldArchives.isEmpty() || newArchives.isEmpty()) {</span>
<span class="nc" id="L212">            enabled = false;</span>
<span class="nc" id="L213">            return;</span>
        }

<span class="fc" id="L216">        passThroughDifferences = StreamSupport.stream(config.path(&quot;passThroughDifferences&quot;).spliterator(), false)</span>
<span class="fc" id="L217">                .map(JsonNode::asText).collect(toList());</span>

<span class="fc" id="L219">        allowedInMajor = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L220">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;major&quot;));</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (allowedInMajor == null) {</span>
<span class="fc" id="L222">            allowedInMajor = VersionIncreaseConfig.DEFAULT_MAJOR;</span>
        }

<span class="fc" id="L225">        allowedInMinor = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L226">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;minor&quot;));</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (allowedInMinor == null) {</span>
<span class="fc" id="L228">            allowedInMinor = VersionIncreaseConfig.DEFAULT_MINOR;</span>
        }

<span class="fc" id="L231">        allowedInPatch = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L232">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;patch&quot;));</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (allowedInPatch == null) {</span>
<span class="fc" id="L234">            allowedInPatch = VersionIncreaseConfig.DEFAULT_PATCH;</span>
        }

<span class="fc" id="L237">        allowedInSuffix = VersionIncreaseConfig.parse(analysisContext,</span>
<span class="fc" id="L238">                config.path(&quot;versionIncreaseAllows&quot;).path(&quot;suffix&quot;));</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (allowedInSuffix == null) {</span>
<span class="fc" id="L240">            allowedInSuffix = VersionIncreaseConfig.DEFAULT_SUFFIX;</span>
        }

<span class="fc" id="L243">        allowedModify = DifferenceModification.parseModify(analysisContext, config.path(&quot;onAllowed&quot;));</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (allowedModify == null) {</span>
<span class="fc" id="L245">            allowedModify = new DifferenceModification(emptyMap(), null, null, null,</span>
<span class="fc" id="L246">                    singletonMap(&quot;breaksVersioningRules&quot;, &quot;false&quot;));</span>
        }
<span class="fc" id="L248">        disallowedModify = DifferenceModification.parseModify(analysisContext, config.path(&quot;onDisallowed&quot;));</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (disallowedModify == null) {</span>
<span class="fc" id="L250">            Criticality breakingCriticality = analysisContext.getDefaultCriticality(DifferenceSeverity.BREAKING);</span>
<span class="fc" id="L251">            disallowedModify = new DifferenceModification(emptyMap(), breakingCriticality, null, null,</span>
<span class="fc" id="L252">                    singletonMap(&quot;breaksVersioningRules&quot;, &quot;true&quot;));</span>
        }

<span class="fc" id="L255">        boolean semantic0 = config.path(&quot;semantic0&quot;).asBoolean(true);</span>

<span class="fc" id="L257">        boolean strictSemver = config.path(&quot;strictSemver&quot;).asBoolean(true);</span>

        // now compute the change hints on the archives
<span class="fc" id="L260">        archiveHints = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        for (Map.Entry&lt;String, Archive.Versioned&gt; e : oldArchives.entrySet()) {</span>
<span class="fc" id="L262">            Archive.Versioned oldArchive = e.getValue();</span>
<span class="fc" id="L263">            Archive.Versioned newArchive = newArchives.remove(e.getKey());</span>

<span class="fc" id="L265">            SemverVersion oldVersion = SemverVersion.parse(oldArchive.getVersion(), strictSemver);</span>

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            if (newArchive == null) {</span>
                // the old archive is no longer part of the API and the classes from it are most probably part
                // of some other archive, possibly in the new API.
                // if we find some difference on some element from such archives, we can encounter:
                // 1) The old was removed (i.e. there is no counterpart anywhere in the new API)
                // 2) The old exists in other archive with some changes
                //
                // In the first case, we should not allow any severity on the old archive. In the second case,
                // we should decide on the semver result based on the version change of the new archive.
                //
                // Therefore, here we just assume the first case. The second case is automatically handled by
                // the fact that we prioritize the new element when looking for the archive in tryTransform().
<span class="nc" id="L279">                archiveHints.put(oldArchive.getBaseName(),</span>
                        new VersionRecord(oldArchive, null, oldVersion, null, VersionChange.REMOVED));
<span class="nc" id="L281">                continue;</span>
            }

<span class="fc" id="L284">            SemverVersion newVersion = SemverVersion.parse(newArchive.getVersion(), strictSemver);</span>

<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            boolean majorIncrease = oldVersion.major &lt; newVersion.major;</span>
<span class="pc bpc" id="L287" title="2 of 4 branches missed.">            boolean minorIncrease = oldVersion.major == newVersion.major &amp;&amp; oldVersion.minor &lt; newVersion.minor;</span>
<span class="pc bpc" id="L288" title="2 of 6 branches missed.">            boolean patchIncrease = oldVersion.major == newVersion.major &amp;&amp; oldVersion.minor == newVersion.minor</span>
                    &amp;&amp; oldVersion.patch &lt; newVersion.patch;
<span class="pc bpc" id="L290" title="2 of 6 branches missed.">            boolean suffixChange = oldVersion.major == newVersion.major &amp;&amp; oldVersion.minor == newVersion.minor</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                    &amp;&amp; oldVersion.patch == newVersion.patch &amp;&amp; !Objects.equals(oldVersion.suffix, newVersion.suffix);</span>

            VersionChange versionChange;
<span class="pc bpc" id="L294" title="4 of 6 branches missed.">            if (semantic0 &amp;&amp; oldVersion.major == 0 &amp;&amp; !majorIncrease) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (minorIncrease) {</span>
<span class="nc" id="L296">                    versionChange = VersionChange.MAJOR;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                } else if (patchIncrease) {</span>
<span class="nc" id="L298">                    versionChange = VersionChange.MAJOR;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                } else if (suffixChange) {</span>
<span class="nc" id="L300">                    versionChange = VersionChange.MAJOR;</span>
                } else {
<span class="nc" id="L302">                    versionChange = VersionChange.NEW;</span>
                }
            } else {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                if (majorIncrease) {</span>
<span class="nc" id="L306">                    versionChange = VersionChange.MAJOR;</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">                } else if (minorIncrease) {</span>
<span class="nc" id="L308">                    versionChange = VersionChange.MINOR;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                } else if (patchIncrease) {</span>
<span class="fc" id="L310">                    versionChange = VersionChange.PATCH;</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                } else if (suffixChange) {</span>
<span class="fc" id="L312">                    versionChange = VersionChange.SUFFIX;</span>
                } else {
<span class="nc" id="L314">                    versionChange = VersionChange.NEW;</span>
                }
            }

<span class="fc" id="L318">            archiveHints.put(newArchive.getBaseName(),</span>
                    new VersionRecord(oldArchive, newArchive, oldVersion, newVersion, versionChange));
<span class="fc" id="L320">        }</span>

        // process the archives in the new API that are not present in the old API
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        for (Map.Entry&lt;String, Archive.Versioned&gt; e : newArchives.entrySet()) {</span>
<span class="nc" id="L324">            SemverVersion newVersion = SemverVersion.parse(e.getValue().getVersion(), strictSemver);</span>

            // There are again 2 cases of the element that we can encounter:
            // 1) The element is brand new (no counter part in any of the archives of the old API)
            // 2) The element has moved from another archive with changes
<span class="nc" id="L329">            archiveHints.put(e.getKey(), new VersionRecord(null, e.getValue(), null, newVersion, VersionChange.NEW));</span>
<span class="nc" id="L330">        }</span>

<span class="fc" id="L332">    }</span>

    private static Difference markUnhandled(Difference orig) {
<span class="fc" id="L335">        return Difference.copy(orig).addAttachment(&quot;breaksVersioningRules&quot;, &quot;unknown&quot;).build();</span>
    }

    private void getAllReferencingAPIElements(@Nullable E element, Set&lt;Archive.Versioned&gt; results, Set&lt;E&gt; processed) {
<span class="pc bpc" id="L339" title="2 of 4 branches missed.">        if (element == null || processed.contains(element)) {</span>
<span class="nc" id="L340">            return;</span>
        }

<span class="fc" id="L343">        processed.add(element);</span>

<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (element.getApi().getArchiveRole(element.getArchive()) == Archive.Role.PRIMARY) {</span>
<span class="fc" id="L346">            results.add((Archive.Versioned) element.getArchive());</span>
        }

<span class="fc" id="L349">        E parent = element.getParent();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L351">            getAllReferencingAPIElements(parent, results, processed);</span>
        }

<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (Reference&lt;E&gt; reference : element.getReferencingElements()) {</span>
<span class="fc" id="L355">            E el = reference.getElement();</span>
<span class="fc" id="L356">            getAllReferencingAPIElements(el, results, processed);</span>
<span class="fc" id="L357">        }</span>
<span class="fc" id="L358">    }</span>

    private static class VersionIncreaseConfig {
<span class="fc" id="L361">        static final VersionIncreaseConfig DEFAULT_MAJOR = new VersionIncreaseConfig(singletonList(new IncreaseAllows(</span>
<span class="fc" id="L362">                false, SeverityCheck.BREAKING, null, null, null, emptyMap(), emptyMap(), emptyList(), null, null)));</span>
<span class="fc" id="L363">        static final VersionIncreaseConfig DEFAULT_MINOR = new VersionIncreaseConfig(</span>
<span class="fc" id="L364">                singletonList(new IncreaseAllows(false, SeverityCheck.NON_BREAKING, null, null, null, emptyMap(),</span>
<span class="fc" id="L365">                        emptyMap(), emptyList(), null, null)));;</span>
<span class="fc" id="L366">        static final VersionIncreaseConfig DEFAULT_PATCH = new VersionIncreaseConfig(singletonList(new IncreaseAllows(</span>
<span class="fc" id="L367">                false, SeverityCheck.EQUIVALENT, null, null, null, emptyMap(), emptyMap(), emptyList(), null, null)));;</span>
<span class="fc" id="L368">        static final VersionIncreaseConfig DEFAULT_SUFFIX = new VersionIncreaseConfig(singletonList(new IncreaseAllows(</span>
<span class="fc" id="L369">                false, SeverityCheck.EQUIVALENT, null, null, null, emptyMap(), emptyMap(), emptyList(), null, null)));;</span>

        final List&lt;IncreaseAllows&gt; allows;

        static @Nullable VersionIncreaseConfig parse(AnalysisContext ctx, JsonNode node) {
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (node.isMissingNode()) {</span>
<span class="fc" id="L375">                return null;</span>
            }

<span class="fc" id="L378">            List&lt;IncreaseAllows&gt; parsedAllows = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (node.isObject()) {</span>
<span class="fc" id="L380">                parsedAllows.add(parseAllows(ctx, node));</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            } else if (node.isArray()) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                for (JsonNode allows : node) {</span>
<span class="nc" id="L383">                    IncreaseAllows a = parseAllows(ctx, allows);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                    if (a != null) {</span>
<span class="nc" id="L385">                        parsedAllows.add(a);</span>
                    }
<span class="nc" id="L387">                }</span>
            } else {
<span class="nc" id="L389">                throw new IllegalArgumentException(</span>
                        &quot;Expecting an object or array when specifying the allowed changes in a version increase.&quot;);
            }

<span class="fc" id="L393">            return new VersionIncreaseConfig(parsedAllows);</span>
        }

        private static @Nullable IncreaseAllows parseAllows(AnalysisContext ctx, JsonNode node) {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if (!node.isObject()) {</span>
<span class="nc" id="L398">                return null;</span>
            }

<span class="fc" id="L401">            boolean regex = node.path(&quot;regex&quot;).asBoolean(false);</span>
            @Nullable
<span class="fc" id="L403">            String severity = node.path(&quot;severity&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L405">            String criticality = node.path(&quot;criticality&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L407">            String code = node.path(&quot;code&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L409">            String justification = node.path(&quot;justification&quot;).asText(null);</span>
<span class="fc" id="L410">            Map&lt;String, String&gt; attachments = new HashMap&lt;&gt;();</span>
<span class="fc" id="L411">            Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; it = node.path(&quot;attachments&quot;).fields();</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L413">                Map.Entry&lt;String, JsonNode&gt; entry = it.next();</span>
<span class="fc" id="L414">                attachments.put(entry.getKey(), entry.getValue().asText());</span>
<span class="fc" id="L415">            }</span>

<span class="fc" id="L417">            Map&lt;CompatibilityType, DifferenceSeverity&gt; classification = new EnumMap&lt;&gt;(CompatibilityType.class);</span>
<span class="fc" id="L418">            it = node.path(&quot;classification&quot;).fields();</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L420">                Map.Entry&lt;String, JsonNode&gt; entry = it.next();</span>
<span class="fc" id="L421">                classification.put(CompatibilityType.valueOf(entry.getKey()),</span>
<span class="fc" id="L422">                        DifferenceSeverity.valueOf(entry.getValue().asText()));</span>
<span class="fc" id="L423">            }</span>

            @Nullable
<span class="fc" id="L426">            String oldSuffix = node.path(&quot;old&quot;).asText(null);</span>
            @Nullable
<span class="fc" id="L428">            String newSuffix = node.path(&quot;new&quot;).asText(null);</span>

<span class="fc" id="L430">            List&lt;String&gt; inArchives = StreamSupport.stream(node.path(&quot;inArchives&quot;).spliterator(), false)</span>
<span class="fc" id="L431">                    .map(JsonNode::asText).collect(toList());</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">            return new IncreaseAllows(regex, severity == null ? null : SeverityCheck.valueOf(severity),</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                    criticality == null ? null : ctx.getCriticalityByName(criticality), code, justification,</span>
                    attachments, classification, inArchives, oldSuffix, newSuffix);
        }

<span class="fc" id="L438">        VersionIncreaseConfig(List&lt;IncreaseAllows&gt; allows) {</span>
<span class="fc" id="L439">            this.allows = allows;</span>
<span class="fc" id="L440">        }</span>

        boolean allows(VersionRecord versionRecord, Difference difference, DifferenceSeverity maxSeverity) {
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">            return allows.stream().reduce(false, (a, b) -&gt; a || b.allows(versionRecord, difference, maxSeverity),</span>
                    Boolean::logicalOr);
        }
    }

    private static class IncreaseAllows {
        final @Nullable SeverityCheck severity;
        final @Nullable Criticality criticality;
        final @Nullable Pattern code;
        final @Nullable Pattern justification;
        final Map&lt;String, Pattern&gt; attachments;
        final Map&lt;CompatibilityType, DifferenceSeverity&gt; classification;
        final List&lt;Pattern&gt; inArchives;
        final @Nullable Pattern oldSuffix;
        final @Nullable Pattern newSuffix;

        private IncreaseAllows(boolean regex, @Nullable SeverityCheck severity, @Nullable Criticality criticality,
                @Nullable String code, @Nullable String justification, Map&lt;String, String&gt; attachments,
                Map&lt;CompatibilityType, DifferenceSeverity&gt; classification, List&lt;String&gt; inArchives,
<span class="fc" id="L462">                @Nullable String oldSuffix, @Nullable String newSuffix) {</span>
<span class="fc" id="L463">            this.severity = severity;</span>
<span class="fc" id="L464">            this.criticality = criticality;</span>
<span class="fc bfc" id="L465" title="All 4 branches covered.">            this.code = code == null ? null : Pattern.compile(regex ? code : Pattern.quote(code));</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            this.justification = justification == null ? null</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">                    : Pattern.compile(regex ? justification : Pattern.quote(justification));</span>
<span class="fc" id="L468">            this.attachments = attachments.entrySet().stream().collect(</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                    toMap(Map.Entry::getKey, e -&gt; Pattern.compile(regex ? e.getValue() : Pattern.quote(e.getValue()))));</span>
<span class="fc" id="L470">            this.classification = classification;</span>
<span class="pc bnc" id="L471" title="All 2 branches missed.">            this.inArchives = inArchives.stream().map(a -&gt; Pattern.compile(regex ? a : Pattern.quote(a)))</span>
<span class="fc" id="L472">                    .collect(toList());</span>
<span class="pc bpc" id="L473" title="1 of 4 branches missed.">            this.oldSuffix = oldSuffix == null ? null : Pattern.compile(regex ? oldSuffix : Pattern.quote(oldSuffix));</span>
<span class="pc bpc" id="L474" title="1 of 4 branches missed.">            this.newSuffix = newSuffix == null ? null : Pattern.compile(regex ? newSuffix : Pattern.quote(newSuffix));</span>
<span class="fc" id="L475">        }</span>

        boolean allows(VersionRecord versionRecord, Difference difference, DifferenceSeverity maxSeverity) {

<span class="pc bpc" id="L479" title="3 of 4 branches missed.">            if (versionRecord.oldArchive == null &amp;&amp; versionRecord.newArchive == null) {</span>
<span class="nc" id="L480">                throw new IllegalStateException(&quot;At least one of the archives must be non-null.&quot;);</span>
            }

            // first we need to match the additional criteria on the archive
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (!inArchives.isEmpty()) {</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">                if (inArchives.stream().noneMatch(p -&gt; p.matcher(versionRecord.newArchive == null</span>
<span class="nc" id="L486">                        ? versionRecord.oldArchive.getBaseName() : versionRecord.newArchive.getBaseName()).matches())) {</span>
<span class="nc" id="L487">                    return false;</span>
                }
            }

<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (this.oldSuffix != null) {</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">                if (versionRecord.oldVersion == null) {</span>
<span class="nc" id="L493">                    return false;</span>
                } else {
<span class="fc" id="L495">                    String suffix = versionRecord.oldVersion.suffix;</span>
<span class="pc bpc" id="L496" title="2 of 4 branches missed.">                    if (!oldSuffix.matcher(suffix == null ? &quot;&quot; : suffix).matches()) {</span>
<span class="nc" id="L497">                        return false;</span>
                    }
                }
            }

<span class="fc bfc" id="L502" title="All 2 branches covered.">            if (this.newSuffix != null) {</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">                if (versionRecord.newVersion == null) {</span>
<span class="nc" id="L504">                    return false;</span>
                } else {
<span class="fc" id="L506">                    String suffix = versionRecord.newVersion.suffix;</span>
<span class="pc bpc" id="L507" title="2 of 4 branches missed.">                    if (!newSuffix.matcher(suffix == null ? &quot;&quot; : suffix).matches()) {</span>
<span class="nc" id="L508">                        return false;</span>
                    }
                }
            }

            // now we can check the difference

<span class="fc bfc" id="L515" title="All 4 branches covered.">            if (this.severity != null &amp;&amp; !this.severity.allows(maxSeverity)) {</span>
<span class="fc" id="L516">                return false;</span>
            }

<span class="pc bpc" id="L519" title="1 of 4 branches missed.">            if (this.criticality != null &amp;&amp; difference.criticality != null</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">                    &amp;&amp; this.criticality.getLevel() &lt; difference.criticality.getLevel()) {</span>
<span class="fc" id="L521">                return false;</span>
            }

<span class="fc bfc" id="L524" title="All 4 branches covered.">            if (this.code != null &amp;&amp; !this.code.matcher(difference.code).matches()) {</span>
<span class="fc" id="L525">                return false;</span>
            }

<span class="fc bfc" id="L528" title="All 2 branches covered.">            if (this.justification != null &amp;&amp; !this.justification</span>
<span class="pc bpc" id="L529" title="1 of 4 branches missed.">                    .matcher(difference.justification == null ? &quot;&quot; : difference.justification).matches()) {</span>
<span class="fc" id="L530">                return false;</span>
            }

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if (this.attachments != null) {</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">                for (Map.Entry&lt;String, Pattern&gt; e : attachments.entrySet()) {</span>
<span class="fc" id="L535">                    String key = e.getKey();</span>
<span class="fc" id="L536">                    Pattern pattern = e.getValue();</span>

<span class="fc" id="L538">                    String value = difference.attachments.get(key);</span>

<span class="fc bfc" id="L540" title="All 4 branches covered.">                    if (!pattern.matcher(value == null ? &quot;&quot; : value).matches()) {</span>
<span class="fc" id="L541">                        return false;</span>
                    }
<span class="fc" id="L543">                }</span>
            }

<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            if (this.classification != null) {</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                for (Map.Entry&lt;CompatibilityType, DifferenceSeverity&gt; e : classification.entrySet()) {</span>
<span class="fc" id="L548">                    DifferenceSeverity expected = e.getValue();</span>
<span class="fc" id="L549">                    DifferenceSeverity actual = difference.classification.get(e.getKey());</span>
<span class="pc bpc" id="L550" title="1 of 4 branches missed.">                    if (actual != null &amp;&amp; expected.compareTo(actual) &lt; 0) {</span>
<span class="fc" id="L551">                        return false;</span>
                    }
<span class="fc" id="L553">                }</span>
            }

<span class="fc" id="L556">            return true;</span>
        }
    }

    private static class DifferenceModification {
        final Map&lt;CompatibilityType, DifferenceSeverity&gt; classification;
        final @Nullable Criticality criticality;
        final @Nullable TextModification justification;
        final @Nullable TextModification description;
        final Map&lt;String, String&gt; attachments;
        final boolean remove;

        private static @Nullable DifferenceModification parseModify(AnalysisContext ctx, JsonNode node) {
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (node.isMissingNode()) {</span>
<span class="fc" id="L570">                return null;</span>
            }

<span class="fc bfc" id="L573" title="All 2 branches covered.">            if (node.path(&quot;remove&quot;).asBoolean(false)) {</span>
<span class="fc" id="L574">                return new DifferenceModification();</span>
            }

<span class="fc" id="L577">            JsonNode classificationNode = node.path(&quot;classification&quot;);</span>
<span class="fc" id="L578">            Map&lt;CompatibilityType, DifferenceSeverity&gt; classification = new EnumMap&lt;&gt;(CompatibilityType.class);</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">            if (classificationNode.has(&quot;SOURCE&quot;)) {</span>
<span class="nc" id="L580">                classification.put(CompatibilityType.SOURCE,</span>
<span class="nc" id="L581">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;SOURCE&quot;).asText()));</span>
            }
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (classificationNode.has(&quot;BINARY&quot;)) {</span>
<span class="nc" id="L584">                classification.put(CompatibilityType.BINARY,</span>
<span class="nc" id="L585">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;BINARY&quot;).asText()));</span>
            }
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">            if (classificationNode.has(&quot;SEMANTIC&quot;)) {</span>
<span class="nc" id="L588">                classification.put(CompatibilityType.SEMANTIC,</span>
<span class="nc" id="L589">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;SEMANTIC&quot;).asText()));</span>
            }
<span class="fc bfc" id="L591" title="All 2 branches covered.">            if (classificationNode.has(&quot;OTHER&quot;)) {</span>
<span class="fc" id="L592">                classification.put(CompatibilityType.OTHER,</span>
<span class="fc" id="L593">                        DifferenceSeverity.valueOf(classificationNode.get(&quot;OTHER&quot;).asText()));</span>
            }

            Criticality criticality;
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (!node.path(&quot;criticality&quot;).isMissingNode()) {</span>
<span class="fc" id="L598">                criticality = ctx.getCriticalityByName(node.path(&quot;criticality&quot;).asText());</span>
            } else {
<span class="fc" id="L600">                criticality = null;</span>
            }

<span class="fc" id="L603">            TextModification justification = parseTextModification(node.path(&quot;justification&quot;));</span>
<span class="fc" id="L604">            TextModification description = parseTextModification(node.path(&quot;description&quot;));</span>

<span class="fc" id="L606">            JsonNode attachmentsNode = node.path(&quot;attachments&quot;);</span>
<span class="fc" id="L607">            Map&lt;String, String&gt; attachments = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (!attachmentsNode.isMissingNode()) {</span>
<span class="fc" id="L609">                Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; it = attachmentsNode.fields();</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L611">                    Map.Entry&lt;String, JsonNode&gt; entry = it.next();</span>
<span class="fc" id="L612">                    attachments.put(entry.getKey(), entry.getValue().asText());</span>
<span class="fc" id="L613">                }</span>
            }

<span class="fc" id="L616">            return new DifferenceModification(classification, criticality, justification, description, attachments);</span>
        }

        @Nullable
        private static TextModification parseTextModification(JsonNode modificationNode) {
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (modificationNode.isTextual()) {</span>
<span class="fc" id="L622">                return new TextModification(modificationNode.asText(), null, null);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            } else if (modificationNode.isObject()) {</span>
<span class="fc" id="L624">                String prepend = modificationNode.path(&quot;prepend&quot;).asText();</span>
<span class="fc" id="L625">                String append = modificationNode.path(&quot;append&quot;).asText();</span>
<span class="fc" id="L626">                return new TextModification(null, prepend, append);</span>
            } else {
<span class="fc" id="L628">                return null;</span>
            }
        }

<span class="fc" id="L632">        private DifferenceModification() {</span>
<span class="fc" id="L633">            this.remove = true;</span>
<span class="fc" id="L634">            this.classification = emptyMap();</span>
<span class="fc" id="L635">            this.criticality = null;</span>
<span class="fc" id="L636">            this.justification = null;</span>
<span class="fc" id="L637">            this.description = null;</span>
<span class="fc" id="L638">            this.attachments = null;</span>
<span class="fc" id="L639">        }</span>

        private DifferenceModification(Map&lt;CompatibilityType, DifferenceSeverity&gt; classification,
                @Nullable Criticality criticality, @Nullable TextModification justification,
<span class="fc" id="L643">                @Nullable TextModification description, Map&lt;String, String&gt; attachments) {</span>
<span class="fc" id="L644">            this.classification = classification;</span>
<span class="fc" id="L645">            this.criticality = criticality;</span>
<span class="fc" id="L646">            this.justification = justification;</span>
<span class="fc" id="L647">            this.description = description;</span>
<span class="fc" id="L648">            this.attachments = attachments;</span>
<span class="fc" id="L649">            this.remove = false;</span>
<span class="fc" id="L650">        }</span>

        TransformationResult modify(Difference difference) {
<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (remove) {</span>
<span class="fc" id="L654">                return TransformationResult.discard();</span>
            }

<span class="fc" id="L657">            Difference.Builder bld = Difference.copy(difference);</span>
<span class="fc" id="L658">            boolean changed = false;</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (!classification.isEmpty()) {</span>
<span class="fc" id="L661">                changed = true;</span>
<span class="fc" id="L662">                bld.addClassifications(classification);</span>
            }

<span class="fc bfc" id="L665" title="All 2 branches covered.">            if (criticality != null) {</span>
<span class="fc" id="L666">                changed = true;</span>
<span class="fc" id="L667">                bld.withCriticality(criticality);</span>
            }

<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (justification != null) {</span>
<span class="fc" id="L671">                changed = true;</span>
<span class="fc" id="L672">                bld.withJustification(justification.apply(difference.justification));</span>
            }

<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (description != null) {</span>
<span class="fc" id="L676">                changed = true;</span>
<span class="fc" id="L677">                bld.withDescription(description.apply(difference.description));</span>
            }

<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (!attachments.isEmpty()) {</span>
<span class="fc" id="L681">                changed = true;</span>
<span class="fc" id="L682">                bld.addAttachments(attachments);</span>
            }

<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (changed) {</span>
<span class="fc" id="L686">                Difference newDiff = bld.build();</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                if (newDiff.equals(difference)) {</span>
<span class="fc" id="L688">                    return TransformationResult.keep();</span>
                } else {
<span class="fc" id="L690">                    return TransformationResult.replaceWith(bld.build());</span>
                }
            } else {
<span class="nc" id="L693">                return TransformationResult.keep();</span>
            }
        }
    }

<span class="fc" id="L698">    private enum SeverityCheck {</span>
<span class="fc" id="L699">        NONE, EQUIVALENT, NON_BREAKING, POTENTIALLY_BREAKING, BREAKING;</span>

        boolean allows(DifferenceSeverity severity) {
<span class="fc bfc" id="L702" title="All 2 branches covered.">            return this.ordinal() &gt;= severity.ordinal() + 1;</span>
        }
    }

    private static class TextModification {
        final @Nullable String value;
        final @Nullable String prepend;
        final @Nullable String append;

<span class="fc" id="L711">        private TextModification(@Nullable String value, @Nullable String prepend, @Nullable String append) {</span>
<span class="fc" id="L712">            this.value = value;</span>
<span class="fc" id="L713">            this.prepend = prepend;</span>
<span class="fc" id="L714">            this.append = append;</span>
<span class="fc" id="L715">        }</span>

        @Nullable
        String apply(@Nullable String value) {
<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (this.value != null) {</span>
<span class="fc" id="L720">                value = this.value;</span>
            }

<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (this.prepend != null) {</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L725">                    value = this.prepend;</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                } else if (!value.startsWith(this.prepend)) {</span>
<span class="fc" id="L727">                    value = this.prepend + value;</span>
                }
            }

<span class="fc bfc" id="L731" title="All 2 branches covered.">            if (this.append != null) {</span>
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L733">                    value = this.append;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                } else if (!value.endsWith(this.append)) {</span>
<span class="fc" id="L735">                    value = value + this.append;</span>
                }
            }

<span class="fc" id="L739">            return value;</span>
        }
    }

    private static final class VersionRecord {
        final @Nullable Archive.Versioned oldArchive;
        final @Nullable Archive.Versioned newArchive;
        final @Nullable SemverVersion oldVersion;
        final @Nullable SemverVersion newVersion;
        final VersionChange versionChange;

        VersionRecord(@Nullable Archive.Versioned oldArchive, @Nullable Archive.Versioned newArchive,
<span class="fc" id="L751">                @Nullable SemverVersion oldVersion, @Nullable SemverVersion newVersion, VersionChange versionChange) {</span>
<span class="fc" id="L752">            this.oldArchive = oldArchive;</span>
<span class="fc" id="L753">            this.newArchive = newArchive;</span>
<span class="fc" id="L754">            this.oldVersion = oldVersion;</span>
<span class="fc" id="L755">            this.newVersion = newVersion;</span>
<span class="fc" id="L756">            this.versionChange = versionChange;</span>
<span class="fc" id="L757">        }</span>
    }

<span class="fc" id="L760">    private enum VersionChange {</span>
<span class="fc" id="L761">        REMOVED, NEW, SUFFIX, PATCH, MINOR, MAJOR;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>